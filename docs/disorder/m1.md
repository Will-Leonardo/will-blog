---
title: 刷题记录
date: 2021-03-15

---
<Boxx type='tip' />

## 合并两个数组
合并数组最容易想到的就是调用数组的api， ```Array.concat(arr)```。

- [```Array.concat(arr)```](https://www.w3school.com.cn/jsref/jsref_concat_array.asp)   
arrayObject.concat(arrayX,arrayX,......,arrayX)，该参数可以是具体的**值**，也可以是**数组对象**。可以是**任意多个**。返回一个**新数组**    
**特点：** 不污染原数组，但也被诟病浪费内存（多次数组合并时）。
```js 
var arr = [1, 2, 3]
var arr2 = [4, 5, 6]
var newArr = arr.concat(arr2)
console.log(newArr)
```

- 拓展运算符 **...**     
...arr 等同于 1,2,3       
**特点：** 性能最佳 
```js
var newArr2 = [...arr, ...arr2]
console.log(newArr2)
```

- for/forEach 配合 push
Array.push(item) 可以在数组尾部追加元素。    
**特点：** 每次循环都要读写内存，性能不佳
```js
for (var i in arr2) {
    arr.push(arr2[i])
}
```

- apply 配合 push   
```arr.push.apply(arr,arr2);``` 看着很‘高大上’，其实只要你能搞到[apply()](https://www.w3school.com.cn/js/js_function_apply.asp) 的作用就能懂      
arr2 是 arr.push的参数列表，只能apply刚好能将参数列表写成数组的形式，刚好也符合了合并数组的需求。

```js
arr.push.apply(arr, arr2)
console.log(arr)
```

## [js 遍历数组的方法](https://blog.fundebug.com/2019/03/11/4-ways-to-loop-array-inj-javascript/)
在JavaScript 中遍历数组的方法很多，但是有一些我们并不会采用，例如在 Airbnb 编码风格禁止使用 for/in 与 for/of。 

- for和 for/in 访问数组下标
```js
for (var i = 0; i < arr.length; i++) {
    console.log(arr[i])
}

for (var index in arr) {
    console.log(arr[index])
}
```

- for/of 直接访问元素的值

```js
for (item of arr) {
    console.log(item)
}
```

- forEach 同时访问下标和元素值
```js
arr.forEach((item, index) => {
    console.log(index, '-', index)
})
```

      


**总结：** 简单地说，for/of是遍历数组最可靠的方式，它比for循环简洁，并且没有for/in和forEach()那么多奇怪的特例。for/of的缺点是我们取索引值不方便，而且不能这样链式调用forEach(). forEach()。


---
:dolphin: ```arr.name = 'lisi'```, 该语句正确吗？ 读者自行思考。



## 内存泄漏
**推荐阅读：** [万恶的前端内存泄漏及万善的解决方案](https://segmentfault.com/a/1190000038816646)        
系统进程不再用到的内存，没有及时释放，就叫做内存泄漏

## 闭包
**推荐阅读：** [理解js闭包的含义](https://www.cnblogs.com/wk-ba/p/10340107.html)，[阮一峰-学习js闭包](http://www.ruanyifeng.com/blog/2009/08/learning_javascript_closures.html)

闭包可以用在许多地方。它的最大用处有两个:      
- 一个是前面提到的**可以读取函数内部的变量**，       
- 另一个就是**让这些变量的值始终保持在内存中** 

## 面向对象理解
**推荐阅读：** [谈一下你对面向对象的理解？](https://blog.csdn.net/u014516981/article/details/52865035),[JavaScript面向对象简介](https://developer.mozilla.org/zh-CN/docs/conflicting/Learn/JavaScript/Objects)

javascript 不是一门严格意义上的面向对象的语言，它并没有提供类的方法。它是使用原型继承而不是类继承达到面向对象的效果


## 函数式编程的理解
**推荐阅读：** [函数式编程初探](https://www.ruanyifeng.com/blog/2012/04/functional_programming.html)

## 斐波那契数列？怎么优化？
斐波那契数列： 1,1,2,3,5,8,13,21 ……  **推荐阅读：** [函数式编程初探](https://zhuanlan.zhihu.com/p/108269159)       
:strawberry: 使用缓存优化 (多看几遍)
```js
function fib(n){
	let cache=[0,1,1]
	function _fib(n){
		if(cache[n]) return cache[n]
		cache[n] = _fib(n-1) + _fib(n-2)
		return cache[n]
	}
	return _fib(n)
}
```
## http 和https的区别？
**注意：** 回答 A 和 B 的区别，当你没有思路时可以先介绍A再介绍B，然后总结A和B的区别,如果你很清楚A和B 的区别就可以直接按点说区别，不用过多的废话。

---


http: 超文本传输协议，最初的目的是提供一种发布和接受HTML页面的方法，可以使浏览器更高效， 通过TCP连接。

https： 以安全为目标的HTTP通道，是HTTP的安全版，


:dolphin: **区别：**    

- HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。
- 使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。
- HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。
- http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。
- HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。

推荐阅读：[HTTP 与 HTTPS 的区别](https://www.runoob.com/w3cnote/http-vs-https.html)


## vue和react的区别?
vue 和 react都是做组件化的，设计之初都是为了数据和ui分离。        
1，vue是渐进式框架（框架做分层设计，每层都可选，不同层可以灵活接入其他方案。） 而 react不是            
2，语法不同，再Vue中推荐使用 template 模板语法， 当然也可以使用 jsx，其实实际上 templa也算是 jsx 的语法糖，react是使用jsx。             
3，react 是单向数据流，组件是纯组件，状态和逻辑是通过参数传入，更改只能通过setdata来实现。Vue是数据双向绑定（MVVM），其实也不算是严格意义上的MVVM，因为只体现在v-model，Vue更准确因该是 数据响应式。          
4，组件的写法react是类式写法， vue是声明式写法。           

##  从“在浏览器输入域名”到“页面静态资源完全加载”的整个流程

这里不再啰嗦，请查看其他文章

##  eventloop（事件循环）
在js中 任务被两种，一种式宏任务（macroTask）， 一种叫微任务（microTask），
- 宏任务：script全部代码、setTimeout、setInterval、setImmediate（浏览器暂时不支持，只有IE10支持，具体可见MDN）、I/O、UI Rendering。
- Process.nextTick（Node独有）、Promise、Object.observe(废弃)、MutationObserver


事件的执行顺序，是先执行宏任务，然后执行微任务，这个是基础，任务可以有同步任务和异步任务，同步的进入主线程，异步的进入Event Table并注册函数，异步事件完成后，会将回调函数放入Event Queue中(宏任务和微任务是不同的Event Queue)，同步任务执行完成后，会从Event Queue中读取事件放入主线程执行，回调函数中可能还会包含不同的任务，因此会循环执行上述操作。


推荐阅读： [一次弄懂Event Loop（彻底解决此类面试问题）](https://zhuanlan.zhihu.com/p/55511602)


## js描述一颗树(数据结构)？

类似于json的写法描述一颗树
```js 
const tree = {
  value: 1,
  left: {
    value: 2,
    left: {
      value: 4
    }
  },
  right: {
    value: 3,
    left: {
      value: 5,
      left: {
        value: 7,
      },
      right: {
        value: 8
      }
    },
    right: {
      value: 6
    }
  }
```
推荐阅读：[用 JavaScript 描述数据结构之树](https://zcdll.github.io/2018/04/06/js-data-structure-tree/)     
树 是一种非顺序数据结构，它用于存储需要快速查找的数据非常有用。

## 递归遍历树和非递归遍历树

:chestnut: 答案查看上面的推荐阅读

- 递归先序遍历
```js
const preOrder = (node) => {
    if (node) {
        console.log(node.value)
        preOrder(node.left)
        preOrder(node.right)
    }
}
```

- 非递归先序遍历   

:dolphin: 关键点在于 pop() 方法用于删除数组的最后一个元素并返回删除的元素，这样就是 ‘后进先出’，然后调整顺序就能达到 先序遍历。
```js 
const iterativePreOrder = (node) => {
  let stack = []
  stack.push(node) // 入栈
  while (stack.length !== 0) {
    if ((node = stack.pop()) != null) { //出栈
      console.log(node.value)
      stack.push(node.right) //右子结点入栈
      stack.push(node.left) //左子结点入栈
    }
  }
}
console.log('非递归先序遍历：')
iterativePreOrder(tree)
```

## 求树的深度

:chestnut: 答案查看上面的推荐阅读

```js 
const getDepth = (node) => {
    if (!node) return 0
    let leftDepth = getDepth(node.left)
    let rightDepth = getDepth(node.right)
    console.log('leftDepth---', leftDepth)
    console.log('rightDepth---', rightDepth)
    return Math.max(leftDepth, rightDepth) + 1
}
console.log('树的深度为：', getDepth(tree))
```

## 描述 js 的 new 操作
new 关键字会进行如下的操作：   

1，创建一个空的简单JavaScript对象（即{}）；         
2，链接该对象（设置该对象的constructor）到另一个对象 ；          
3，将步骤1新创建的对象作为this的上下文 ；        
4，如果该函数没有返回对象，则返回this。 

推荐阅读：[如何自己实现 JavaScript 的 new 操作符？](https://segmentfault.com/a/1190000022140993)
## 自己实现一个 new操作 

推荐阅读：[如何自己实现 JavaScript 的 new 操作符？](https://segmentfault.com/a/1190000022140993)


## JavaScript 中 call()、apply()、bind() 的用法
```call()```、```apply()```、```bind()```都可以修改this的指向。   

:fish: 首先我们得了解什么是this？  [this的原理](http://www.ruanyifeng.com/blog/2018/06/javascript-this.html)
> 面向对象语言中this表示当前对象的一个引用(定义一个变量指向一个对象)。

:fish:  [javascript中this的指向问题](https://www.cnblogs.com/chengxs/p/8679313.html)
> 哪个对象调用函数，函数里面的this指向哪个对象



