---
title:  2021-11-04
date: 2021-11-04
---

<Boxx type='tip' />

## position: fixed 和 position：sticky
:chestnut: 需求：页面往下滑动，滑动到某个位置时，导航位置固定。      
这个需求需要通过定位来做，```position: static | relative | absolute | fixed | sticky```。
[css-position](https://www.runoob.com/css/css-positioning.html) 

- 思路一： 当下滑到导航时，导航固定， position：fixed （不推荐）

[Element.getBoundingClientRect()](https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect) 方法返回元素的大小及其相对于视口的位置。

```js
mounted() {
    window.addEventListener('scroll', this.appScroll);
}
// ……
appScroll() {
    const navToTop = this.$refs.preBeforeSet.getBoundingClientRect().top;
    // console.log(navToTop);
    if (navToTop <= 0) {
      // console.log('固定菜单栏')
      this.$refs.siderNav.style.position = 'fixed';
      this.$refs.siderNav.style.top = '0px';
      this.$refs.siderNav.style.left = '12vw';
    } else {
      // 正常显示
      this.$refs.siderNav.style.position = 'absolute';
      this.$refs.siderNav.style.top = '';
      this.$refs.siderNav.style.left = '';
    }
}
```

- 思路二： 使用定位 ```position:sticky```
当窗口滑动到该div时，自动固定位置，往上滑动时，又自动恢复原来的布局 
```css
.nav{
    position: sticky;
    height: 20vh;
    left: 10vw;
    top: 0vw;
}
 
```
:strawberry: **【注意】**：

1，上述两种定位，一定要结合 ```left、top、right、bottom```来使用，否则失效 
2，使用```position:sticky``` 时，
- 不能与父div同高
- 父div一定要设置高度
- 滑动超过父div后，自动恢复原来的布局 

## 2，特殊a标签
|点击打电话(在小程序中有所不同)， |点击发邮件
|--|--|
|:href="`tel:${manager.phone}`"   | :href="`mailto:${manager.email}`"|
|……|……|


## 3，css 动画（）与变形
突然觉得好久没有使用过css动画了，简单复习一下。 css 的动画有 ```transition（过渡）```

[css动画简介](https://www.ruanyifeng.com/blog/2014/02/css_transition_and_animation.html)

- transition
局限：
（1）transition需要事件触发，所以没法在网页加载时自动发生。      
（2）transition是一次性的，不能重复发生，除非一再触发。      
（3）transition只能定义开始状态和结束状态，不能定义中间状态，也就是说只有两个状态。      
（4）一条transition规则，只能定义一个属性的变化，不能涉及多个属性。       
```css
.className{
    transition: all 1s 1s ease;
}
```
- animation

```css
div:hover {
  animation: 1s 1s rainbow linear 3 forwards normal;
}
// 等同于上面代码
div:hover {
  animation-name: rainbow;
  animation-duration: 1s;
  animation-timing-function: linear;
  animation-delay: 1s;
    animation-fill-mode:forwards;
  animation-direction: normal;
  animation-iteration-count: 3;
}

@keyframes rainbow {
  0% { background: #c00; }
  50% { background: orange; }
  100% { background: yellowgreen; }
}
```
## 4，一个js文件export要求写default时
```js
const getUserList = (id) => {
  console.log(id)
}
export default getUserList
```

## 5, [教程] | 一篇Axios入门教程
参考：
- [一篇Axios入门教程](https://juejin.cn/post/6884561821127491597)
- [Axios post 传参的params 与data 的两种形式](https://blog.csdn.net/yangyangkl123/article/details/109024222)

## 6, 页面布局问题

场景：拿到设计稿先看看布局，居中布局简单  ```margin: xx auto;``` 就搞定，而且能适应各种分辨率屏幕, 但非居中呢？
目前我能想到的有： 1，使用栅格布局； 2，使用vw，vh，em等单位；3，响应式

## 7，js中==和===区别 【基础知识】

记住： ==表示相等（可通过类型转换后相等，例如 ’‘ == 0  //true）， === 表示相同；

## 8，div中文字显示问题

- 居中

```css
.main{
    height: 100px;
    text-align: center;  /* 水平居中 */
    line-height: 100px;  /* 单行文本行高等于height大小就可以垂直居中了 */
    /* */
}
    
```

- 首字母

```css
.main::first-letter{  /* 伪元素 */
   font-size: 20px;
   color: red;
}
```
- 超出显示 ...

```css
.main{
    overflow: hidden;  /* 超出隐藏 */
}

/* 不超过2行，超出显示 ... */
.main{
    overflow: hidden;
    text-overflow: ellipsis;
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
}
```

## 9， Vue路由传参

- 动态路由匹配
router.js
```js
{
    path: '/user/:id',
    name: 'user',
    component: () => import('../views/user.vue')
}
```
当路由匹配成功时，例如:``` /user/123 ```或者``` /user/456 ```都会匹配到```'/user/:id',```, 则在 user.vue 组件中可以使用
``` this.$route.id ``` 获取到 动态路由参数。

- 路由组件传参
命名视图: 解释见官网


```js
const User = {
  props: ['id'],
  template: '<div>User {{ id }}</div>'
}


const router = new VueRouter({
  routes: [
    { path: '/user/:id', component: User, props: true },

    // 对于包含命名视图的路由，你必须分别为每个命名视图添加 `props` 选项：
    {
      path: '/user/:id',
      components: { default: User, sidebar: Sidebar },
      props: { default: true, sidebar: false }
    }
  ]
})
```

**对象模式**: 如果 props 是一个对象，它会被按原样设置为组件属性。当 props 是静态(不变)的时候有用。 

```js
const router = new VueRouter({
  routes: [
    {
      path: '/promotion/from-newsletter',
      component: Promotion,
      props: { newsletterPopup: false }
    }
  ]
})

// ……

const User = {
  props: ['newsletterPopup'],
  template: '<div>User {{ newsletterPopup }}</div>'  // false
}

// ……

```
**函数模式**：URL /search?q=vue 会将 {query: 'vue'} 作为属性传递给 SearchUser 组件。

```js
const router = new VueRouter({
  routes: [
    {
      path: '/search',
      component: SearchUser,
      props: route => ({ query: route.query.q })
    }
  ]
})
```
```js
// 编程式
this.$router.push({ 
        path: '/generalSet',
        query: {
          tabId: this.tabId,
        },
      });
```

::: details 更多案例
```js
import Vue from 'vue'
import VueRouter from 'vue-router'
import Hello from './Hello.vue'

Vue.use(VueRouter)

function dynamicPropsFn (route) {
  const now = new Date()
  return {
    name: (now.getFullYear() + parseInt(route.params.years)) + '!'
  }
}

const router = new VueRouter({
  mode: 'history',
  base: __dirname,
  routes: [
    { path: '/', component: Hello }, // No props, no nothing
    { path: '/hello/:name', component: Hello, props: true }, // Pass route.params to props
    { path: '/static', component: Hello, props: { name: 'world' }}, // static values
    { path: '/dynamic/:years', component: Hello, props: dynamicPropsFn }, // custom logic for mapping between route and props
    { path: '/attrs', component: Hello, props: { name: 'attrs' }}
  ]
})

new Vue({
  router,
  template: `
    <div id="app">
      <h1>Route props</h1>
      <ul>
        <li><router-link to="/">/</router-link></li>
        <li><router-link to="/hello/you">/hello/you</router-link></li>
        <li><router-link to="/static">/static</router-link></li>
        <li><router-link to="/dynamic/1">/dynamic/1</router-link></li>
        <li><router-link to="/attrs">/attrs</router-link></li>
      </ul>
      <router-view class="view" foo="123"></router-view>
    </div>
  `
}).$mount('#app')
```
:::

## 10, vue中'. native'修饰符的使用 
现在在组件上使用 v-on 只会监听自定义事件 (组件用 $emit 触发的事件)。如果要监听根元素的原生事件，可以使用 .native 修饰符，比如：
```<my-component v-on:click.native="doSomething"></my-component>```

**注意**： 直接使用 ```<my-component v-on:click="doSomething"></my-component>``` 会报错， 自定义组件设定时就是只有组件用 $emit 触发的事件，你可以这样写。

```html
  <Footer  @myEvent='handleDbClick'></Footer>

  <template>
  <div class="footer" @dblclick="clickdb">footer</div>
  </template>
```
```js
clickdb () {
  this.$emit('myEvent', 'luoliu')
}

handleDbClick (val) {
  console.log('我被', val, 'dbClick')
}
```

## 11，scoped 里面不许使用 * { } 通配符号

## 12, Vuex

## 13，.sync 
