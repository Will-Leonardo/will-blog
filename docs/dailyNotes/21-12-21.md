---
title:  2021-12-21
date: 2021-12-21
---

<Boxx type='tip' />

## todo

1, 整理 zs-wj 的代码，包括 README.md    √ 

2, 写好学习纪录   √      

3, 合并代码，上线 zs-wj 和 zhaoshangweb √

4, 新建 zs-clue-h5 项目  （ × ） // 无需新建项目，原有招商助手项目

5, 想想怎么完善博客里面的todo  （ × ）

## 今日阅读
<!-- 代码规范 -->
- https://juejin.cn/post/7040855578679181342?utm_source=gold_browser_extension

<!-- ts -->
- https://juejin.cn/post/7011689911707238414?utm_source=gold_browser_extension 

- http://ts.xcatliu.com/introduction/what-is-typescript.html 

<!-- keep-alive 相关 -->

- https://www.jianshu.com/p/ad5a16550d58 

- https://www.jianshu.com/p/575498c82f9a 

- https://zhuanlan.zhihu.com/p/93161800 

<!-- other -->
- https://juejin.cn/post/6990146025100935205?utm_source=gold_browser_extension 

## 今日视频

今日午休观看bilibili如何用副业赚钱

:strawberry: 1，网络上流传的 无货源开网店、配音等等其实门槛是有的，而且也需要花很多时间做。 2，教人赚钱最赚钱。 3，干好主业，通过主业衍生副业最好。


## beforeRouteLeave  当 path不变不触发？

## keep-alive 大总结

> 在做招商线索获取移动端时，遇到页面组件缓存相关和衍生的问题等，例如：1，滚动无限加载被缓存，在下个页面滚动也会触发。
2，在编辑页面，未做任何修改（相当于查看详情），返回主页时，应该缓存状态（不刷新，维持之前的滚动条位置等），修改了数据时，返回主页面，就
应该刷新数据。3，（移动端重点考虑）在主页点击返回应该退出应用，而不是返回前一条路由纪录，所以要注意路由栈，合理使用 ```this.router.push```\
```this.router.replace```\ ```this.router.go(-1)``` \ ```this.router.back()```

### 什么是 keep-alive？ 有啥子用？

> <keep-alive> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <transition> 相似，<keep-alive> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在组件的父组件链中。

> 当组件在 <keep-alive> 内被切换时，它的 mounted 和 unmounted 生命周期钩子不会被调用，取而代之的是 activated 和 deactivated。(这会运用在 <keep-alive> 的直接子节点及其所有子孙节点。)

> 主要用于保留组件状态或避免重新渲染。


- Props：
   - include - string | RegExp | Array。只有名称匹配的组件会被缓存。
   - exclude - string | RegExp | Array。任何名称匹配的组件都不会被缓存。
   - max - number | string。最多可以缓存多少组件实例。

参考：[Vue官方教程](https://v3.cn.vuejs.org/api/built-in-components.html#keep-alive)


:chestnut: 案例二 **（重要）**

```HTML
<template>
  <div id="app">
    <!-- 缓存页面 -->
    <vue-page-stack>
      <router-view :key="$route.fullPath" class="router-view" v-if="$route.meta.keepAlive" />
    </vue-page-stack>
    <!-- 非缓存页面 -->
    <router-view v-if="!$route.meta.keepAlive">
    </router-view>
  </div>
</template>
```

router.js：利用路由原meta来设定是否需要缓存（路由原可以用来设定组件和路由耦合比较紧的信息）
```js
{
    path: '/list',
    meta: {
      title: '招商线索收集',
      keepAlive: true // 需要被缓存
    },
    component: () => import(/* webpackChunkName: "list" */ '../views/clueList.vue')
  },
  {
    path: '/detail',
    meta: {
      title: '问卷详情',
      keepAlive: true // 需要被缓存
    },
    component: () => import(/* webpackChunkName: "detail" */ '../views/detail.vue')
  },
  {
    path: '/form',
    component: () => import(/* webpackChunkName: "form" */ '../views/form/index.vue'),
    meta: {
      keepAlive: false // 不需要被缓存
    }
}
```

pageA：离开打断无限加载，进入开启无限加载
```js
created () {
  this.requestData(this.pageNum, this.pageSize)
},
activated () {
  // 开启无限加载
  this.loading = false
},
deactivated () {
  // 打断无限加载
  this.loading = true
}
```
pageB: 跳转到A页面区分刷新与不刷新
```js
beforeRouteLeave (to, from, next) {
  // 有操作才刷新列表
  if (to.path === '/list' && this.hashandle) {
    to.meta.keepAlive = false
  } else {
    to.meta.keepAlive = true
  }
  next()
}
```

- 无限加载

在移动端，我们常见的都是滚动加载，所用到的组件为无限加载（infinite-load）

原理：滚动到页面底部加载下一页。

核心代码：

```js {4}
loadmore () {
  const scrollDistance = (this.scrollObj && this.scrollObj.getBoundingClientRect ? this.scrollObj.getBoundingClientRect().top : 0) + this.scrollContainerHeight + this.offset
  if (this.$refs.loadmore.getBoundingClientRect().top <= scrollDistance && !this.loading && !this.isFinished && !this.isError) {
    this.$emit('loadmore')
  }
},
loadEnd () {
  this.isFinished = true
  this.scrollObj.removeEventListener('scroll', this.loadmore)
},
```

## encodeURIComponent

场景：我使用了一个 ```href="xxx.jd.com/index/from?id=123&returnUrl=https://xxx.jd.com"```, 在codereview时，被指出要求使用encodeURIComponent，避免解析错误。

> encodeURIComponent()函数通过将一个，两个，三个或四个表示字符的UTF-8编码的转义序列替换某些字符的每个实例来编码 URI （对于由两个“代理”字符组成的字符而言，将仅是四个转义序列） 。

```h
 :href="`https://xx.jd.com/Register?settleType=4&returnUrl=${encodeURIComponent('https://xxx.jd.com')`"
```

## 代码规范

场景：空格，符号问题被指出蛮尴尬的，😁

推荐阅读：[先做人后做事,先学规范再写代码](https://juejin.cn/post/7040855578679181342?utm_source=gold_browser_extension)

