---
title: 延迟函数
date: 2022-06-24
categories: 
 - javaScript
---
<Boxx type='tip' />

## 延迟函数

1. 利用Promise和setTimeout简单做出一个简单的延迟函数
   
```js
<script setup>
import { ref } from "vue";

    let msg = ref('')
    const delay = (ms, options)=>{
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if(options.willResolve){
                    resolve(options.value)
                }else{
                    reject({
                        message: '失败了喔'
                    })
                }
            }, ms);
        })
    }
    const handleClick = async ()=>{
        try {
            const res =  await delay(1000, { value: '999', willResolve: false })
        } catch (error) {
            console.log(error.message)
        }
    }
</script>

```

```html
<template>
    <button @click="handleClick">发出延时函数</button> <br/>
    {{ msg }}
</template>
```

2. 可以随机时间返回
   
> 可以学习一些函数的写法， Vue3中函数用的比较多
   
```js
<script setup>
import { ref } from "vue";

    let msg = ref('')
    /**
     * 随机整数
     * 
     * @param {*} min 最小值
     * @param {*} max 最大值
     * 
     * @return {int} 随机值
     */
    const randomInteger = (min,max)=>{
        return Math.floor((Math.random() * (max - min + 1)) + min)
    }
    
    // 柯里化函数
    const createDelay = ({willResolve}) => (ms, options={}) => {
        return new Promise((resolve, reject) => {
            setTimeout(() => {
                if(willResolve){
                    resolve(options.value)
                }else{
                    reject({
                        message: '失败了喔',
                        options
                    })
                }
            }, ms);
        })
    }

    const createDelayWithTime = ()=>{
        const delay = createDelay({willResolve: true})
        delay.reject = createDelay({willResolve: false})
        delay.range =  (minimum, maximum, options) => delay(randomInteger(minimum, maximum), options);
        return delay
    }
    const myDelay = createDelayWithTime()
    const handleClick = async ()=>{
        try {
            const res =  await myDelay.range(10,2000,{value:'这是个测试'})
            console.log('成功',res)
        } catch (error) {
            console.log(error)
        }
    }
</script>
```

```html
<template>
    <button @click="handleClick">发出延时函数</button> <br/>
    {{ msg }}
</template>
```


3. 提前清除

本来应该再 2000ms后出现结果，实际上在300ms后就出现了
```js
<script setup>
import { ref } from "vue";

let msg = ref('')
/**
 * 随机整数
 * 
 * @param {*} min 最小值
 * @param {*} max 最大值
 * 
 * @return {int} 随机值
 */
const randomInteger = (min, max) => {
    return Math.floor((Math.random() * (max - min + 1)) + min)
}

// 柯里化函数
const createDelay = ({ willResolve }) => (ms, options = {}) => {
    let settle;
    let timeoutId;
    const delayPromise =  new Promise((resolve, reject) => {
        settle = () => {
               if (willResolve) {
                   resolve(options)
               } else {
                   reject({
                       message: '失败了喔',
                       options
                   })
               }
           }
        timeoutId = setTimeout(settle, ms);
    })
    // 结束延迟，立即执行需要执行的逻辑
    delayPromise.clear = ()=>{
        clearTimeout(timeoutId)
        timeoutId = null
        settle()
    }
    return delayPromise
}

const createDelayWithTime = () => {
    const delay = createDelay({ willResolve: true })
    delay.reject = createDelay({ willResolve: false })
    delay.range = (minimum, maximum, options) => delay(randomInteger(minimum, maximum), options);
    return delay
}
const myDelay = createDelayWithTime()
const handleClick = async () => {
    try {
        const delayPromise = myDelay(2000, { value: '这是个测试' })
        // delayPromise
        setTimeout(()=>{
            delayPromise.clear()
        },300)
        console.log(await delayPromise)
    } catch (error) {
        console.log(error)
    }
}
</script>
```

```html
<template>
    <button @click="handleClick">发出延时函数</button> <br />
    {{ msg }}
</template>
```



## 参考文章

- [简明 JavaScript 函数式编程——入门篇](https://segmentfault.com/a/1190000020302184)
- [理解Javascript的柯里化](https://segmentfault.com/a/1190000021677898)
- [面试官：请手写一个带取消功能的延迟函数，axios 取消功能的原理是什么](https://juejin.cn/post/7042461373904715812)