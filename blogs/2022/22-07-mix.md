---
title:  Vue.js挑战
date: 2022-07-12
categories: 
 - Vue
---
<Boxx type='tip' />


## props验证

```Vue
<script setup lang='ts'>
import { defineProps } from 'vue';
defineProps({
    btnType:{
        type: String,
        default: 'default',
        validator: (val: string)=>{
            return  ["primary", "ghost", "dashed" ,"link" ,"text" ,"default"].includes(val)
        }
    }
})
</script>

<template>
  <div></div>
</template>
<style  scoped>
</style>
```


## 函数式组件

```vue
<script setup lang='ts'>

import { ref, h } from "vue"

/**
 * Implement the functional component :
 * 1. Render list elements (ul/li) with list data
 * 2. Change the list item text color to be red when click it.
*/
const ListComponent = (props, { emit }) => h(
  'ul',
  props.list.map((item: { name: string }, index: number) => h(
    'li',
    {
      onClick: () => emit('toggle', index),
      style: index === props.activeIndex ? { color: 'red' } : null,
    },
    {
      default: () => item.name
    }
  ))
)

ListComponent.props = ['list', 'activeIndex']
ListComponent.emits = ['toggle']

const list = [{
  name: "John",
}, {
  name: "Doe",
}, {
  name: "Smith",
}]

const activeIndex = ref(0)

function toggle(index: number) {
  activeIndex.value = index
}

</script>

<template>
  <list-component
    :list="list"
    :active-index="activeIndex"
    @toggle="toggle"
  />
</template>
```

## 渲染函数

```js{10,12}
import { defineComponent,h } from "vue"

export default defineComponent({
  name: 'MyButton',
  render() {
    return h(
    'button',
      {
        ...this.$attrs,
        onClick: ()=>{ this.$emit('customClick') }
      },
      this.$slots.default()
    )
  }
})
```

## 树组件

TreeComponent.vue, vue组件可以使用组件本身

```Vue
<script setup lang="ts">
interface TreeData {
  key: string
  title: string
  children: TreeData[]
}
defineProps<{data: TreeData[]}>()
</script>

<template>
  <!-- do something.... -->
  <ul>
    <template v-for="item in data" :key="item.key">
    	<li >{{ item.title }}</li>
      <ul v-if="item.children && Array(item.children)">
         <TreeComponent :data="item.children" />
      </ul>
    </template>
  </ul>
</template>
```


## 切换器

```Vue
<script setup lang='ts'>
import { ref } from 'vue'
/**
 * Implement a composable function that toggles the state
 * Make the function work correctly
*/
function useToggle(flag: Boolean):[state: Boolean, toggle: () => void ] {
  const state = ref(flag)
  const toggle = ()=>{
    state.value = !state.value
  }
  return [state,toggle]
}

const [state, toggle] = useToggle(false)

</script>

<template>
  <p>State: {{ state ? 'ON' : 'OFF' }}</p>
  <p @click="toggle">
    Toggle state
  </p>
</template>
```

## 计数器

tip: 注意min和max是可选参数

```Vue
<script setup lang="ts">
import { ref, watch } from 'vue';
interface UseCounterOptions {
  min?: number;
  max?: number;
}

/**
 * Implement the composable function
 * Make sure the function works correctly
 */
function useCounter(initialValue = 0, options: UseCounterOptions = {}) {
  const { min, max } = options;
  const count = ref(initialValue);
  const inc = () => {
    count.value++;
  };
  const dec = () => {
    count.value--;
  };
  const rest = () => {
    count.value = initialValue;
  };
  watch(count, (new_val, old_val) => {
    if (
      min !== undefined &&
      max !== undefined &&
      (new_val > max || new_val < min)
    ) {
      count.value = old_val;
    }
  });
  return {
    count,
    inc,
    dec,
    rest,
  };
}

const { count, inc, dec, reset } = useCounter(0, { min: 0, max: 10 });
</script>

<template>
  <p>Count: {{ count }}</p>
  <button @click="inc">inc</button>
  <button @click="dec">dec</button>
  <button @click="reset">reset</button>
</template>

```


## 本地存储函数

**tip:** 存储的数据类型为 any, 也就是存在 对象和数组等引用数据类型，我们知道```localStorage.setItem(key,value)```会
将```key```和```value```强制转化为字符串类型，将引用类型直接存储```localStorage.setItem(key,['1','2'])```, 会变成
"['1','2']"。 所以我们应该使用 ```JSON.stringify``` 和 ```JSON.parse```将数据转化为JSON字符串。

```Vue
<script setup lang="ts">
import { ref, watchEffect } from 'vue';

/**
 * Implement the composable function
 * Make sure the function works correctly
 */
function useLocalStorage(key: string, initialValue: any) {
  const initial = JSON.parse(localStorage.getItem(key)) || initialValue;
  const value = ref(initial);
  watchEffect(() => {
    localStorage.setItem(key, JSON.stringify(value.value));
  });
  return value;
}

const counter = useLocalStorage('counter', 0);

// We can get localStorage by triggering the getter:
console.log(counter.value);

// And we can also set localStorage by triggering the setter:

const update = () => counter.value++;
</script>

<template>
  <p>Counter: {{ counter }}</p>
  <button @click="update">Update</button>
</template>
```

## ref全家桶

ref、reactive、isRef、toRef、unref

```Vue
<script setup lang="ts">
import { ref, Ref, reactive ,isRef,toRef,unref} from "vue"

const initial = ref(10)
const count = ref(0)

// Challenge 1: Update ref
function update(value) {
  // impl..
  count.value = value
}

/**
 * Challenge 2: Check if the `count` is a ref object.
 * Make the output be 1
*/
console.log(
  // impl ? 1 : 0
  isRef(count)? 1: 0
)

/**
 * Challenge 3: Unwrap ref
 * Make the output be true
*/
function initialCount(value: number | Ref<number>) {
  // Make the output be true
  console.log(unref(value) === 10)
  return unref(value)
}

initialCount(initial)

/**
 * Challenge 4:
 * create a ref for a property on a source reactive object.
 * The created ref is synced with its source property:
 * mutating the source property will update the ref, and vice-versa.
 * Make the output be true
*/
const state = reactive({
  foo: 1,
  bar: 2,
})
const fooRef = toRef(state,'foo') // change the impl...

// mutating the ref updates the original
fooRef.value++
console.log(state.foo === 2)

// mutating the original also updates the ref
state.foo++
console.log(fooRef.value === 3)

</script>

<template>
  <div>
    <p>
      <span @click="update(count-1)">-</span>
      {{ count }}
      <span @click="update(count+1)">+</span>
    </p>
  </div>
</template>

```

## 可写的计算属性

记得在vue2中可写的计算属性是这么写的，vue3相似

```Vue
data(){
    return{
        lastName: '',
        firstName: ''
    }
},
computed:{
    fullName:{
        set:()=>{
            this.firstName + ' ' + lastName
        },
        get:(newValue)=>{
            var names = newValue.split(' ')
            this.firstName = names[0]
            this.lastName = names[names.length - 1]
        }
    }
}

```

## watch 全家桶

参考：[侦听器](https://staging-cn.vuejs.org/guide/essentials/watchers.html)

```vue
<script setup lang="ts">
import { ref, watch, reactive } from 'vue';

const count = ref(0);

/**
 * Challenge 1: Watch once
 * Make sure the watch callback only triggers once
 */
const stopWatch = watch(count, () => {
  console.log('Only triggered once');
});

count.value = 1;
setTimeout(() => {
  stopWatch();
  count.value = 2;
});

/**
 * Challenge 2: Watch object
 * Make sure the watch callback is triggered
 */
const state = ref({
  count: 0,
});

watch(
  // getter
  () => {
    return state.value.count;
  },
  () => {
    console.log('The state.count updated');
  }
  //{ deep: true }
);

state.value.count = 2;

// 方法2

// const state = ref({
//   count: 0,
// });

// watch(
//   state
//   () => {
//     console.log('The state.count updated');
//   },
//   { deep: true }
// );

// state.value.count = 2;

/**
 * Challenge 3: Callback Flush Timing
 * Make sure visited the updated eleRef
 */

const eleRef = ref();
const age = ref(2);
watch(
  age,
  () => {
    console.log(eleRef.value);
  },
  // 回调刷新时机
  {
    flush: 'post',
  }
);
age.value = 18;
</script>

<template>
  <div>
    <p>
      {{ count }}
    </p>
    <p ref="eleRef">
      {{ age }}
    </p>
  </div>
</template>

```

## 浅层 ref  shallowRef()

参考： [shallowRef()使用场景](https://www.csdn.net/tags/MtTaMg0sNDY2NDQzLWJsb2cO0O0O.html)

ref 其实是封装的 reactive

```const name = ref('lisi')``` 实际上就是 ```const name = reactive({value: 'lisi '})```

所以使用```ref```创建的变量需要用 ```.value```

shallowRef,shallowReactive, 用来做非递归监听，但一般情况下我们使用ref或者reactive即可，只在需要监听 的数据量比较大的时候才使用

shallowRef是通过监听数据的.value变化，来实现数据响应
shallowReactives是通过监听最外层的数据变化，才能触发视图更新

shallowReactive视图更新只有触发第一层数据，也就是触发.value.也就是，shallowRef需要触发.value

```Vue
<script setup lang="ts">
import { shallowRef, watch } from 'vue';

const state = shallowRef({ count: 1 });

// Does NOT trigger
watch(
  state,
  () => {
    console.log('State.count Updated');
  },
  { deep: true }
);

/**
 * Modify the code so that we can make the watch callback trigger.
 */

// 非递归监听，并不会触发 watch回调
// state.value.count = 2;

state.value = { count: 2 }

</script>

<template>
  <div>
    <p>
      {{ state.count }}
    </p>
  </div>
</template>

```

## inject() 和 provide()

```js
const count = ref(1)
provide("count", count)
```

```Vue
<script setup lang="ts">
// Add a piece of code to make the `count` value get injected into the child component.
import { inject } from 'vue'
const count = inject('count')
</script>

<template>
  {{ count }}
</template>

```


## 自定义修饰符

```Vue
<script setup>
import { ref, vModelText } from 'vue'

const _vModelText = vModelText

_vModelText.updated = (el, { value, modifiers: { capitalize } }) => {
  if (capitalize && value.hasOwnProperty(0)) {
    el.value = value[0].toUpperCase() + value.substr(1)
  }
}

const v = ref("")
</script>

<template>
  <input type="text" v-model.capitalize="v" />
</template>
```


## 自定义指令

一个指令的定义对象可以提供几种钩子函数 (都是可选的)，钩子函数参数

参考: [自定义指令](https://staging-cn.vuejs.org/guide/reusability/custom-directives.html#introduce)

```vue{13,14}
<script setup lang='ts'>
import { ref } from "vue"

const state = ref(false)

/**
 * Implement the custom directive
 * Make sure the input element focuses/blurs when the 'state' is toggled
 *
*/

const VFocus = {
  updated(el,bing) {
    if (bing.value) {
      el.focus()
    } else {
      el.blur()
    }
  }
}

setInterval(() => {
  state.value = !state.value
}, 2000)

</script>

<template>
  <input v-focus="state" type="text">
</template>
```

## toRaw 和 markRaw


toRaw 可以将 proxy转成原始对象，raw表示未加工的

markRaw 标记为未加工的

**谨慎使用**

```vue
<script setup lang="ts">
import { reactive, isReactive,toRaw,markRaw } from "vue"

const state = { count: 1 }
const reactiveState = reactive(state)

/**
 * Modify the code so that we can make the output be true.
*/
console.log(toRaw(reactiveState) === state)

/**
 * Modify the code so that we can make the output be false.
*/
const info = { count: 1 }
const reactiveInfo = markRaw(info)

console.log(isReactive(reactiveInfo))

</script>

<template>
  <div>
    <p>
      {{ reactiveState.count }}
    </p>
  </div>
</template>
```
