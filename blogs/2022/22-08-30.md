---
title:  店铺星级项目总结
date: 2022-08-30
categories: 
 - 总结
---
<Boxx type='tip' />

## 1. 布局组件

在一个项目中往往会出现多个页面，多个页面一般都会存在 页面标题、模块标题、header、footer
这些相同部分，我们可以抽出成组件，使用 ```slot``` 插槽作为拓展。

例如： ```src/components/layout/PageTitle.vue```

```vue
<!-- 页面标题 -->
<script setup lang='ts'>
import { defineProps, toRefs } from 'vue';

interface PageTitleType{
    title?: string,
    menuList?: Array<string>
}
const props = defineProps<PageTitleType>();
const { title, menuList } = toRefs(props);
</script>

<template>
  <div v-if="title" class="tw-flex tw-items-center tw-mb-4 tw-relative">
    <div class="title tw-mr-6">{{ title }}</div>
    <el-breadcrumb separator="/" v-if="menuList">
      <template v-for="item in menuList" :key="item">
        <el-breadcrumb-item>{{ item }}</el-breadcrumb-item>
      </template>
    </el-breadcrumb>
    <slot></slot>
  </div>
</template>
```   

```src/components/layout/ModuleTitle.vue```

```vue
<!-- 模块标题 二级标题-->
<template>
  <div class="module-title-wrap">
    <div class="module-title-wrap__title"> {{ title }}</div>
    <div v-if="desc" class="module-title-wrap__desc">{{ desc }}</div>
    <slot></slot>
  </div>
</template>

<script lang="ts">
import { defineComponent } from 'vue';

export default defineComponent({
  name: 'ModuleTitle',
  props: {
    title: String,
    desc: String,
  },
});
</script>
```

## 2. 组合api composition-api

在vue3中，多使用组合式api，函数式编程。 组合式api相比于选项式api优点在于**相关业务或者逻辑的数据和方法写在一起**，这样形成了
一个小封装，使用的时候只需要传参和使用返回值(数据和方法)，不必太关心内部，这样也提高了代码的可读性和可维护性。

例如： ```src/composition-api/useTabs```

```Ts
interface useTabsOptions{
    initActive?: string, // 默认选中
    tabClick?: (tab: TabsPaneContext, event: Event)=> void
    noAuthList?:Ref<Array<string>> // 无权tabsList
}
interface tabsObject{
    name: string,
    label: string,
    auth?: boolean,
}
/**
 * @description: tabs 组合api
 * @param {Array} list : tabs 初始list
 * @param {useTabsOptions} options 配置项
 * @return {*}
 */
export default function useTabs(list: Array<tabsObject>, options?:useTabsOptions) {
  const tabsList = ref(list);
  const noAuthList = ref(options?.noAuthList);
  const activeTabName = ref(options?.initActive ?? tabsList.value[0]?.name);
  const activeTabLabel = computed(() => {
    const tab = tabsList.value.find((item) => item.name === activeTabName.value);
    return tab?.label;
  });
  const handleTabClick = (tab: TabsPaneContext, event: Event) => {
    if (options?.tabClick) {
      options?.tabClick(tab, event);
    }
    // ……
  };
  return {
    activeTabName,
    activeTabLabel,
    tabsList,
    handleTabClick,
  };
}
```

```ts
const {
  activeTabName, activeTabLabel, tabsList, handleTabClick,
} = useTabs(
  VANE_DICT.tabsList,
  { initActive: 'tab1', noAuthList },
);
```

**more：** [VueUse](https://vueuse.org/functions.html) 有许多封装好的组合式api的工具类函数， 我也是是看了相关的源码，导致我写业务相关的组合式api时也朝着工具类函数(复用性强、多靠参数支持)方向去写了，这很不对，其实，**组合式api并不需要考虑太多的复用性，重点在于逻辑抽离**，将合适的逻辑抽离到一个use函数中。  共勉


## 3. 词典 dict

在前端项目中其实写死了很多数据，也有部分硬编码，这时为了统一管理，也为了方便阅读，我们会写一些 ```枚举、对象、数组```, 我们可以在 将这些固定的数据写在一个文件中方便管理。

```src/dict/index.ts```

```ts
export { default as VANE_DICT } from './vane';
```

```vane.ts```
```ts
const explainListIndex = ['①', '②', '③'];

export default {
    explainListIndex
}
```

使用：
```Ts
import { VANE_DICT } from '@/dict/index';

console.log(VANE_DICT.explainListIndex)
```


## 4. sessionStorage 的使用

```sessionStorage``` 刷新页面后数据不丢失，页面关闭数据才删除，  pinia、vux页面刷新数据丢失

存取复杂类型数据

```ts
sessionStorage.setItem('shopInfo', JSON.stringify(shopInfo.value));
```

```ts
const shopInfo = JSON.parse(sessionStorage.getItem('shopInfo') || JSON.stringify(''));
```

## 5. tailwindcss 的使用

这次项目偏向使用新框架，也结合了 tailwindcss 意图在减少写css代码。
tailwindcss其实是通过预设的样式，达到只写类名来控制样式的。 使用可以参考官网[tailwindcss](https://www.tailwindcss.cn/) 

例如：

```vue
<!-- 自定义了前置 tw- ，避免与其他自己写的类名冲突 -->
<div class="tw-border-normal tw-border tw-rounded tw-flex-shrink-0 tw-relative">
</div>
```

::: details tailwind 配置文件

```tailwind.config.js```

```js
module.exports = {
  prefix: 'tw-', // 前缀
  purge: ['./index.html', './src/**/*.{vue,js,ts,jsx,tsx}'],
  darkMode: false, // or 'media' or 'class'
  theme: {
    extend: { // 自己额外的配置
      backgroundColor: () => ({
        success: '#04C76F',
        error: '#ED2828',
        normal: '#BFBFBF',
      }),
      textColor: () => ({
        whitesmoky: '#8C8C8C',
      }),
      borderColor: () => ({
        greyE8: '#E8E8E8',
        normal: '#D9D9D9', // 普通边框和烟灰色相近
      }),
      fontSize: {
        xxs: ['10px', '18px'],
        xs: ['12px', '20px'],
        sm: ['14px', '22px'], // font-size: 14; line-height: 22px;
        base: ['16px', '24px'],
        lg: ['20px', '28px'],
        xl: ['24px', '32px'],
        xxl: ['32px', '38px'],
      },
    },
    screens: {
      tablet: '640px',
      // => @media (min-width: 640px) { ... }

      laptop: '1024px',
      // => @media (min-width: 1024px) { ... }

      desktop: '1280px',
      // => @media (min-width: 1280px) { ... }
    },
  },
  variants: {
    extend: {},
  },
    // 重要：目前网上的一个解法，解决element按钮样式出错问题  
  plugins: [
    function ({ addBase }) {
      addBase({
        '.el-button': {
          'background-color': 'var(--el-button-bg-color,var(--el-color-white))',
        },
      });
    },
  ],
};
```
:::

## 6. TypeScript 的使用

这次项目采用的是 vue3 + Ts， 刚开始使用确实因为标红而头疼，但是写了一定的逻辑代码后，你一定会觉得很香。 类型检查避免了一定的类型问题（例如
```number``` 和 ```string```, 当你给一个number类型的变量赋字符串类型的数据时就会报错，等等）

- [ts 入门](https://ts.xcatliu.com/introduction/hello-typescript.html)
- [深入理解ts](https://jkchao.github.io/typescript-book-chinese)

```ts
VANE_DICT.lineChartType[factorType as keyof typeof VANE_DICT.lineChartType]
```

```ts
import {
  defineProps, toRefs, ref, withDefaults, watch,
} from 'vue';

const props = withDefaults(defineProps<{
  modelValue: number | null | string,
}>(), {
  modelValue: 0,
});
```

### 参考资料

- [写 TypeScript 时，很多人可能会犯的几个错误！ - 掘金](https://juejin.cn/post/7142162881956544526#heading-2)


## 7. 动态引入图片

```vue
    <!-- <img :src="require(`@/assets/icon/` +  equityData.img + '.svg' )" alt="权益" class="tw-mx-auto"> -->
```

## 8. 自动路由

项目中，只要按照规则创建文件，就会自动生成路由。

```ts
import autoRoutes from '@vue-plugin-auto-router';

const routes: Array<RouteRecordRaw> = [
  ...autoRoutes,
];
```

## 9. to be continue……

