---
title:  日常笔记0914
date: 2022-09-14
categories: 
 - 日常笔记
---
<Boxx type='tip' />

## useSlots() 和 useAttrs()

在 ``<script setup>`` 使用 slots 和 attrs 的情况应该是相对来说较为罕见的，
因为可以在模板中直接通过 $slots 和 $attrs 来访问它们。


```vue
<script setup lang='ts'>
import { useSlots, useAttrs } from 'vue';

const attrs = useAttrs();
</script>

<template>
  <div>{{ attrs }}</div>
  <div>{{ $attrs }}</div>
</template>
<style  scoped>
</style>
```

截取自element的源码，表示loading组件可以作为插槽自定义。
```vue
<template>
    <slot v-if="$slots.loading" name="loading" />
</template>
```

## 自己写个组件库

相信干前端的都有想过自己写个组件库，那就行动 

参考资料：

https://www.51cto.com/article/717743.html 


## monorepo 单一代码库

参考资料：[前端 Monorepo 实践](https://juejin.cn/post/7036016254385127431)

Monorepo 的意思是在版本控制系统的单个代码库里包含了许多项目的代码。这些项目虽然有可能是相关的，但通常在逻辑上是独立的，并由不同的团队维护 


## 依赖注入 provide() 和 inject()

依赖注入，在vue项目中使用的比较多，下面讲一下补充点，针对vue3

- provide

提供一个值，可以被后代组件注入。

provide() 必须在组件的 setup() 阶段同步调用。

```vue
<script setup>
import { ref, provide } from 'vue'
import { fooSymbol } from './injectionSymbols'

// 提供静态值
provide('foo', 'bar')

// 提供响应式的值
const count = ref(0)
provide('count', count)

// 提供时将 Symbol 作为 key
provide(fooSymbol, count)
</script>
```

- inject

注入一个由祖先组件或整个应用 (通过 app.provide()) 提供的值。

第一个参数是注入的 key。Vue 会遍历父组件链，通过匹配 key 来确定所提供的值。如果父组件链上多个组件对同一个 key 提供了值，那么离得更近的组件将会“覆盖”链上更远的组件所提供的值。如果没有能通过 key 匹配到值，inject() 将返回 undefined，除非提供了一个默认值

```vue
<script setup>
import { inject } from 'vue'
import { fooSymbol } from './injectionSymbols'

// 注入值的默认方式
const foo = inject('foo')

// 注入响应式的值
const count = inject('count')

// 通过 Symbol 类型的 key 注入
const foo2 = inject(fooSymbol)

// 注入一个值，若为空则使用提供的默认值
const bar = inject('foo', 'default value')

// 注入一个值，若为空则使用提供的工厂函数
const baz = inject('foo', () => new Map())

// 注入时为了表明提供的默认值是个函数，需要传入第三个参数
const fn = inject('function', () => {}, false)
</script>
```

- 类型标注

创建一个特殊的常量文件来保存 Injectable 键，例如：

```ts
// symbols.ts
import { InjectionKey } from 'vue';
import { Product } from '@/types';
const ProductKey: InjectionKey<Product> = Symbol('Product');
```

```ts
// types.ts
interface Product { name: string; price: number;}
```

```ts
import { provide } from 'vue';
import { ProductKey } from '@/symbols';
// ⛔️ Argument of type 'string' is not assignable to ...
provide(ProductKey, 'this will not work');
// ✅
provide(ProductKey, {
  name: 'Amazing T-Shirt',
  price: 100,
});
```

```ts
import { inject } from 'vue';
import { ProductKey } from '@/symbols';
// ⛔️ Argument of type 'string' is not assignable to ...
const product = inject(ProductKey, 'nope');
// ✅ Type checks out
const product = inject(ProductKey, { name: '', price: 0 });
```

```ts
// types.ts
interface Product {
  name: string;
  price: number;
}
// symbols.ts
import { InjectionKey, Ref } from 'vue';
import { Product } from '@/types';
const ProductKey: InjectionKey<Ref<Product>> = Symbol('Product');
```



