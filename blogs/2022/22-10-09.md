---
title:  前端路由理解与实现
date: 2022-10-09
categories: 
 - vue
---
<Boxx type='tip' />



## 参考资料

- [面试官为啥总是喜欢问前端路由实现方式？](https://juejin.cn/post/7127143415879303204)[推荐:star:]


## hash模式

一个URL是由很多部分组成，包括协议、域名、路径、query、`hash`等

浏览器已经暴露给我们一个现成的方法```hashchange```，在hash改变的时候，触发该事件。有了监听事件，且改变hash页面并不刷新，这样我们就可以在监听事件的回调函数中，执行我们展示和隐藏不同UI显示的功能，从而实现前端路由。

- hash模式所有的工作都是在前端完成的，不需要后端服务的配合
- hash模式的实现方式就是通过监听URL中hash部分的变化，从而做出对应的渲染逻辑
- hash模式下，URL中会带有#，看起来不太美观

:::details hash模式前端路由简单实现
```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        *{
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        html,
        body{
            height: 100%;
        }
        #content {
            height: calc(100vh - 50px);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
        }
        #nav{
            height: 50px;
            position: fixed;
            left: 0;
            bottom: 0;
            width: 100%;
            display: flex;
        }
        #nav a{
            width: 25%;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 1px solid black;
        }
        #nav a:not(:last-of-type){
            border-right: none;
        }
    </style>
</head>
<body>
    <main id="content"></main>
    <nav id="nav">
        <a href="#/">首页</a>
        <a href="#/shop">商城</a>
        <a href="#/shopping-cart">购物车</a>
        <a href="#/mine">我的</a>
    </nav>
</body>
<script>
    class VueRouter {
        constructor(routes = []){
            this.routes = routes; //路由映射
            this.currentHash = ""; // 当前的hash
            this.refresh = this.refresh.bind(this); 
            window.addEventListener("load", this.refresh, false)
            window.addEventListener("hashchange", this.refresh, false)
        }
        getUrlPath(url){
            // 获取hash
            return url.indexOf("#") >= 0 ? url.slice(url.indexOf("#") + 1) : '/'
        }
        refresh(event){
            console.log(event)
            let newHash = "";
            let  oldHash = null;
            if(event.newURL){
                oldHash = this.getUrlPath(event.oldURL || "");
                newHash = this.getUrlPath(event.newURL|| "")
            }else{
                newHash = this.getUrlPath(window.location.hash)
            }
            console.log(newHash)
            this.currentHash = newHash;
            this.matchComponent();
        }
        matchComponent(){
            let curRoute = this.routes.find(
                (route) => route.path === this.currentHash
            )
            if(!curRoute){
                curRoute = this.routes.find((route)=> route === "/")
            }
            const { component } = curRoute;
            document.querySelector('#content').innerHTML = component
        }
    }
    
    const router = new VueRouter([
        {
          path: "/",
          name: "home",
          component: "<div>首页内容</div>"
        },
        {
          path: "/shop",
          name: "shop",
          component: "<div>商城内容</div>"
        },
        {
          path: "/shopping-cart",
          name: "shopping-cart",
          component: "<div>购物车内容</div>"
        },
        {
          path: "/mine",
          name: "mine",
          component: "<div>我的内容</div>"
        }
    ])
</script>
</html>
```
:::

## history模式

history路由的实现，主要就是依靠于pushState与replaceState实现的

- window.history.pushState 可以将给定的数据压入到浏览器会话历史栈中
- window.history.replaceState 将当前的会话页面的url替换成指定

