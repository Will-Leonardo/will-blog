---
title:  vueUse
date: 2022-07-15
categories: 
 - Vue
---
<Boxx type='tip' />

vueUse 是一款基于Vue组合式API的函数工具集；

以下是我看文档和源码整理的一些资料，帮助我们去学习Vue3的组合api和一些常用的工具函数。

源码注释版,详细 []()

## useCycleList

Cycle through a list of items. (通过每项循环浏览list)


:::details
```js
/**
 * Cycle through a list of items
 *
 * @param list 循环的数组
 * @param option (可选) 
 */
export function useCycleList<T>(list: T[], options?: UseCycleListOptions<T>) {
  // 1. ?? 比 ||
  // 2. ref 和 shallowRef 定义的变量是 interface Ref<T>
  const state = shallowRef(options?.initialValue ?? list[0]) as Ref<T>

  const index = computed<number>({
    get() {
      // 3. 存在自定义的 获取索引函数时优先使用 自定义的，否则使用 Array.indexOf()
      let index = options?.getIndexOf
        ? options.getIndexOf(state.value, list)
        : list.indexOf(state.value)
      
      // 4. 当索引值 小于0时，优先使用自定义的 fallbackIndex 回退索引，否则为 0 
      if (index < 0)
        index = options?.fallbackIndex ?? 0

      return index
    },
    set(v) {
      set(v)
    },
  })

  function set(i: number) {
    const length = list.length
    // 5. 越界index 转成循环 例如：length = 5， i = 7，index应该等于 2
    const index = (i % length + length) % length
    const value = list[index]
    state.value = value
    return value
  }

  function shift(delta = 1) {
    return set(index.value + delta)
  }

  function next(n = 1) {
    return shift(n)
  }

  function prev(n = 1) {
    return shift(-n)
  }

  return {
    state,
    index,
    next,
    prev,
  }
}
 
```
:::

## unrefElement

通过ref 获取元素 或 Vue组件实例的引用的dom元素

原理：
- 1. unref 其实是 `val = isRef(val) ? val.value : val`，用来发挥真实值

- 2. Vue组件实例是 `ComponentPublicInstance`类型
  
```js
export type VueInstance = ComponentPublicInstance

// ……

return (plain as VueInstance)?.$el ?? plain

```



```Vue
<script setup lang='ts'>
import  { ref } from 'vue'
const input = ref()
const hello = ref()
onMounted(() => {
    console.log(input) // RefImpl 对象
    console.log(input.value) // <input>
    console.log(unrefElement(hello)) // <div class='test'>……</div>
    console.log(unrefElement(hello).style) // {accentColor: '', additiveSymbols: ''……}
})
</script>

<template>
  <div>
    <input ref="input">
    <hello-world-vue ref="hello"></hello-world-vue>
  </div>
</template>
```

## useActiveElement

- 主要利用的是js api `window.document.activeElement` 
- hook函数可以返回 计算属性，这样可以动态变动

:::details
```js
export function useActiveElement<T extends HTMLElement>(options: ConfigurableWindow = {}) {
  const { window = defaultWindow } = options
  const counter = ref(0)

  if (window) {
    useEventListener(window, 'blur', () => counter.value += 1, true)
    useEventListener(window, 'focus', () => counter.value += 1, true)
  }

  return computed(() => {
    // eslint-disable-next-line no-unused-expressions
    counter.value
    return window?.document.activeElement as T | null | undefined
  })
}
```
:::

## useAsyncState

反应式异步状态， loading、error、execute等

这个应该是常用的，建议项目中可以简单的自行封装一个

```js
// ……
async function execute(delay = 0, ...args: any[]) {
  try {
      const data = await _promise
      state.value = data
      isReady.value = true
    }
    catch (e) {
      error.value = e
      onError(e)
    }
    finally {
      isLoading.value = false
    }

    return state.value as Data
}

if (immediate)
  execute(delay)
// ……
```
 