---
title:  JS数组去重的几种常见方法
date: 2021-7-7
categories: 
 - javaScript
---
<Boxx type='tip' />

## 简单的去重方法
新建一新数组，遍历传入数组，值不在新数组就push进该新数组中。   
利用数组的```indexOf```的返回值可以判断数组中是否包含某个数据。        
当数组中包含改元素时返回索引，当不包含时返回-1. 
```js 
function uniq(array) {
    let temp = []
    for (let i = 0; i < array.length; i++) {
        if (temp.indexOf(array[i]) == -1) {
            temp.push(array[i])
        }
    }

    return temp
}

console.log(uniq([1, 2, 3, 4, 5, 6, 2, 2, 5, 3])) // [ 1, 2, 3, 4, 5, 6 ]
```

## 对象键值法去重

**思路：** 新建一js对象以及新数组，遍历传入数组时，判断值是否为js对象的键，
不是的话给对象新增该键并放入新数组。
注意点：判断是否为js对象键时，会自动对传入的键执行“toString()”，
不同的键可能会被误认为一样，例如n[val]-- n[1]、n["1"]；
解决上述问题还是得调用“indexOf”。    
**关键点：** js中对象可以像数组一样用下标的方式去访问数组的属性。例如： ```person[name]```
::: details 

js中对象可以像数组一样用下标的方式去访问数组的属性，也可以使用下标的方式去定义属性，但是属性值会被自动转换成字符串类型。
```js
let person = {
    "name": "lisi",
    1: "属性为一个数",
    "string": "属性为一个字符串",
    "1": "123",
    // 1: "属性为一个数",
}

for (let key in person) {
    console.log(key, "---", typeof key, "----", person[key])
}

console.log(person[1])
```
--- 
**遍历对象的几种方式**   
1, for(let key in obj)
```js
for (let key in person) {
    console.log(key, person[key])
}
```
2, Object.keys(obj) 和 Object.values(obj)
```js
console.log(Object.keys(person))
console.log(Object.values(person))
```
3, Object.getOwnPropertyNames(obj)
返回一个数组，包含对象自身的所有属性
```js
Object.getOwnPropertyNames(person).forEach(key => {
    console.log(key, '---', person[key])
})
```
:::
```js
function uniq(array) {
    let temp = {}
    let res = []
    let val = ""
    let type = ""
    for (let i = 0; i < array.length; i++) {
        val = array[i]
        type = typeof val
        if (!temp[val]) {
            temp[val] = [type]
            res.push(val)
        } else if (temp[val].indexOf(type) < 0) {
            temp[val].push(type)
            res.push(val)
        }
    }
    return res
}

console.log(uniq([1, 2, 3, 4, 5, 6, 2, 2, 5, 3, "1", "2", "a", "true"]))
```


## 排序后相邻去除法  
**思路：** 新数组不加入重复值
```js
function uniq(array) {
    array.sort((a, b) => a - b)
    let temp = []
    temp[0] = array[0]
    for (let i; i < array.length; i++) {
        if (array[i] !== temp[temp.length - 1]) {
            temp.push(array[i])
        }
    }
    return temp
}
```

## 数组下标法

**思路：** 如果当前数组的第i项在当前数组中第一次出现的位置不是i，
那么表示第i项是重复的，忽略掉。否则存入结果数组。
```js
function uniq(array) {
    let temp = []
    for (let i = 0; i < array.length; i++) {
        if (array.indexOf(array[i]) == i) {
            temp.push(array[i])
        }
    }
    return temp
}


console.log(uniq([1, 2, 3, 4, 5, 6, 2, 2, 5, 3, "1", "2", "a", "true"]))
```

## 优化遍历数组法
有点像滑动窗口问题。
```js 
// 思路：获取没重复的最右一值放入新数组
/*
* 推荐的方法
*
* 方法的实现代码相当酷炫，
* 实现思路：获取没重复的最右一值放入新数组。
* （检测到有重复值时终止当前循环同时进入顶层循环的下一轮判断）*/
function uniq(array){
    var temp = [];
    var index = [];
    var l = array.length;
    for(var i = 0; i < l; i++) {
        for(var j = i + 1; j < l; j++){
            if (array[i] === array[j]){
                i++;
                j = i;
            }
        }
        temp.push(array[i]);
        index.push(i);
    }
    console.log(index);
    return temp;
}

var aa = [1,2,2,3,5,3,6,5];
console.log(uniq(aa));
```

