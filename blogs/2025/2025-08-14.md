---
title: 前端需要掌握的简单算法
date: 2025-08-14
categories: 
 - 算法
---


- 题目：  
```
示例 1:

输入: nums1 = [1,2,2,1], nums2 = [2,2]
输出: [2,2]
示例 2:

输入: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出: [4,9]
```
- 思路：   
为两个数组分别建立 map，用来存储 num -> count 的键值对，统计每个数字出现的数量。
然后对其中一个 map 进行遍历，查看这个数字在两个数组中分别出现的数量，取出现的最小的那个数量（比如数组 1 中出现了 1 次，数组 2 中出现了 2 次，那么交集应该取 1 次），push 到结果数组中即可

- 答案：
```js
let intersect = function (nums1, nums2) {
  let map1 = makeCountMap(nums1)
  let map2 = makeCountMap(nums2)
  let res = []
  for (let num of map1.keys()) {
    const count1 = map1.get(num)
    const count2 = map2.get(num)

    // 如果在map中num也存在
    if (count2) {
      // 取出现次数小的那个数据 
      const pushCount = Math.min(count1, count2)
      // 将数据插入到res数组中  
      for (let i = 0; i < pushCount; i++) {
        res.push(num)
      }
    }
  }
  return res
}

// 将数组转换成Map数据类型  Map(7) { 1 => 3, 2 => 3, 3 => 1, 4 => 2, 5 => 1, 6 => 1, 8 => 1 }
function makeCountMap(nums) {
  let map = new Map()
  for (let i = 0; i < nums.length; i++) {
    let num = nums[i]
    let count = map.get(num)
    if (count) {
      map.set(num, count + 1)
    } else {
      map.set(num, 1)
    }
  }
  
  // map 中 num=>count  num: 数字, count: 出现的次数   
  return map
}
```



- 题目：   
给定一个包括  n 个整数的数组  nums  和 一个目标值  target。找出  nums  中的三个整数，使得它们的和与  target  最接近。返回这三个数的和。假定每组输入只存在唯一答案。

```
示例：

输入：nums = [-1,2,1,-4], target = 1
输出：2
解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。
```

- 思路        
先按照升序排序，然后分别从左往右依次选择一个基础点 i（0 <= i <= nums.length - 3），在基础点的右侧用双指针去不断的找最小的差值。
假设基础点是 i，初始化的时候，双指针分别是：

left：i + 1，基础点右边一位。
right: nums.length - 1 数组最后一位。

然后求此时的和，如果和大于 target，那么可以把右指针左移一位，去试试更小一点的值，反之则把左指针右移。
在这个过程中，不断更新全局的最小差值 min，和此时记录下来的和 res。
最后返回 res 即可。

- 答案   
```js
let threeSumClosest = function (nums, target) {
    let n = nums.length
    if (n === 3) {
      return getSum(nums)
    }
    // 先升序排序 此为解题的前置条件
    nums.sort((a, b) => a - b)
  
    let min = Infinity // 和 target 的最小差
    let res
  
    // 从左往右依次尝试定一个基础指针 右边至少再保留两位 否则无法凑成3个
    for (let i = 0; i <= nums.length - 3; i++) {
      let basic = nums[i]
      let left = i + 1 // 左指针先从 i 右侧的第一位开始尝试
      let right = n - 1 // 右指针先从数组最后一项开始尝试
  
      while (left < right) {
        let sum = basic + nums[left] + nums[right] // 三数求和
        // 更新最小差
        let diff = Math.abs(sum - target)
        if (diff < min) {
          min = diff
          res = sum
        }
        if (sum < target) {
          // 求出的和如果小于目标值的话 可以尝试把左指针右移 扩大值
          left++
        } else if (sum > target) {
          // 反之则右指针左移
          right--
        } else {
          // 相等的话 差就为0 一定是答案
          return sum
        }
      }
    }
  
    return res
  }
  
  function getSum(nums) {
    return nums.reduce((total, cur) => total + cur, 0)
  }

  
```

- 要点

1, 利用Array.reduce()计算数组和   
reduce() 方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。
> array.reduce(function(total, currentValue, currentIndex, arr), initialValue) 

|参数|	描述|
|--|--|
|total|	必需。初始值, 或者计算结束后的返回值。|
|currentValue|	必需。当前元素|
|currentIndex |可选。当前元素的索引|
|arr|	可选。当前元素所属的数组对象。|

```js
function getArraySum(nums){
    return nums.reduce((total, curr)=> total + curr, 0)
}
```

2, 数组排序
array.sort() 默认升序
```
arr.sort((a,b)=>a-b) // 升序
arr.sort((a,b)=>b-a) // 降序 
```

3, 求绝对值```Math.abs()```
```js
console.log(1-2)
```



---
title:  算法 - 滑动窗口问题
date: 2021-07-05
categories: 
 - 算法
---
<Boxx type='tip' />

- 题目：
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

- 思路：
定义左边界left；右边界right；形成一个窗口，并且在这个窗口中保证不出现重复的字符串。

- 答案：
```js
var lengthOfLongestSubstring = function(s) {
    let n = s.length
    let left = 0
    let right = -1
    let freqMap = {}
    while (left < n) {
        let nextLetter = s[right + 1]
        if (!freqMap[nextLetter] && nextLetter !== undefined) {
            freqMap[nextLetter] = 1
            right++
        } else {
            freqMap[s[left]] = 0
            left++
        }
        max = Math, max(max, right - left + 1)
    }
    return max
};
```
- 要点：
1，利用了hash结构 




## 题目： 两数和
给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。
 
```
示例 1：

输入：x = 123
输出：321
```

## 答案：
1，暴力解法：
- 将数字的每一位存储在数组中
- 判断数组的第一个元素是不是'-'，从而区分正负数
- 如果是正数，先翻转，再转为数字，然后判断是否越界；如果是负数，先移除数组的第一个元素'-'，先翻转，再转为数字，然后判断是否越界；

```js
var reverse = function(x) {
    let arr = x.toString().split('')
    let num

    // 正数
    if (arr[0] !== '-') {
        num = Number(arr.reverse().join(""))
        return range(num)
    } else {
        arr.shift()
        num = Number(arr.reverse().join(""))
        return range(-num)
    }
};

let range = (num) => {
        if (num >= (-Math.pow(2, 31)) && num <= (Math.pow(2, 31) - 1)) {
            return num
        } else {
            return 0
        }
}
```

2，数学方法：参考链接 [整数反转](https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-qu-zheng-yun-suan-by-6bw2/)
整体思路就是遍历（x / 10）数字x，每次拿数字的个位（x % 10），直到拿完。
每次遍历都将x的个位 拼接到result的新腾出的个位上（result = result * 10 + (x % 10);）

**技巧：** ~~取整

::: details ~按位取反
~按位取反

对于整数相当于取反减一
```
~0 === -1
~1 === -2
~-1 === 0
~-2 === 1
```
对于小数相当于舍去小数位再取反减一

```
~0.3 === -1
~1.7 === -2
~-0.3 === -1
~-1.2 === 0
~-2.9 === 1
```
~~按位取反再取反

对于整数还是自身

```
~~1 === 1
~~-1 === -1
~~0 === 0
```
对于小数，等于舍去小数位
相当于正数向下取整，负数向上取整
```

~~1.1 === 1
~~1.9 === 1
~~-1.1 === -1
~~-1.9 === -1
```

【技巧】Math.floor()向下取整
Math.floor() 是向下取整
```
Math.floor(1.1) === 1
Math.floor(1.9) === 1
Math.floor(-1.1) === -2
Math.floor(-1.9) === -2
```

:::
```js
var reverse = function(x) {
    let res = 0;
    while (x) {
        res = res * 10 + x % 10;
        if (res > Math.pow(2, 31) - 1 || res < Math.pow(-2, 31)) return 0;
        x = ~~(x / 10);
    }
    return res;
};

```


## 题目： 寻找两个正序数组的中位数
给定两个大小分别为m和n的正序（从小到大）数组nums1和nums2。请你找出并返回这两个正序数组的中位数。

## 思路：
1，暴力解法：将两个数组合并,排序,然后取中位数。      
2, 双指针法：因为两个数组有序，求中位数不需要把两个数组合并
当合并后的数组总长度len为奇数时，只要知道索引为len/2位置上的数就行了，如果数偶数，只要知道索引为len/2 - 1和len/2上的数就行，所以不管是奇数还是偶数只要遍历len/2次即可，用两个值来存遍历过程中len/2-1和len/2上的数即可
两个指针point1和point2分别指向nums1和nums2，当nums1[point1] < nums2[point2]，则point1指针移动，否则point2指针移动

3, 二分法查找： 参考[官方解答](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/solution/xun-zhao-liang-ge-you-xu-shu-zu-de-zhong-wei-s-114/) 
## 答案： 
1, 暴力解法
```js
var findMedianSortedArrays = function(nums1, nums2) {
    
    let long = nums1.length + nums2.length
    let nums = nums1.concat(nums2).sort((a, b) => a - b)

    let result = long % 2 == 0 ? (nums[long / 2] + nums[long / 2 - 1]) / 2 : nums[Math.floor(long / 2)]
    return result
};
```

2, 双指针法
```js
var findMedianSortedArrays = function(nums1, nums2) {
    let n1 = nums1.length
    let n2 = nums2.length

    let len = n1 + n2
    let preValue = -1
    let curValue = -1

    let point1 = 0
    let point2 = 0

    for (let i = 0; i <= Math.floor(len / 2); i++) {
        preValue = curValue
        if (point1 < n1 && (point2 >= n2 || nums1[point1] < nums2[point2])) {
            curValue = nums1[point1]
            point1++
        } else {
            curValue = nums2[point2]
            point2++
        }
    }
    return len % 2 == 0 ? (preValue + curValue) / 2 : curValue


};
```

## 要点： 

1，暴力解法：
- concat 合并数组
> concat 可以合并两个或者多个数组，并返回一个新数组

- 简单的判断不一定要用if，也可以用三元运算符

2, ----

3, 二分法：理解每次二分后可以排除一些不可能的值