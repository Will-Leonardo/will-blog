---
title: web前端面试知识点
date: 2024-11-25
categories: 
 - 前端基础
---
<Boxx type='tip' />

## 说说你对vue的理解

Vue是目前国内比较流行的用于构建用户界面的javascript框架，有易学易用，性能出色，灵活多变的特点。它的设计哲学是渐进式的，他只关注视图层，通过配合使用其他库和工具（例如： vue-router、vuex、Typescript等），它也能够帮助开发者构建复杂的前端应用。它的要素在于 *响应式系统、组件化、模版语法、虚拟dom*、有健全的工具链和生态系统，社区文档都比较齐全。

- 响应式系统：Vue通过使用响应式系统自动追踪依赖和管理DOM更新。当模型状态改变时，视图会自动更新，这使得状态管理变得简单高效。
- 组件化：Vue鼓励开发者通过组件化的方式构建应用，每个组件都有自己的视图、数据逻辑和样式，这样有助于提高代码的复用性和测试性。
- 模板语法：Vue使用基于HTML的模板语法，允许开发者声明式地将DOM绑定到底层Vue实例的数据上。模板支持数据绑定、指令（如v-if、v-for等）、事件处理等。
- 虚拟DOM：Vue使用虚拟DOM来优化DOM的更新，通过计算前后两次数据变化产生的差异，然后高效地批量更新DOM，而不是直接操作DOM。

## 那你讲讲Vue的响应式

- [深入响应式原理](https://v2.cn.vuejs.org/v2/guide/reactivity.html)
- [深入响应式系统](https://v2.cn.vuejs.org/v2/guide/reactivity.html)

*首先什么是响应式？*

个经常被拿来当作典型例子的用例即是 Excel 表格：
单元格 A2 中的值是通过公式 = A0 + A1 来定义的 (你可以在 A2 上点击来查看或编辑该公式)，因此最终得到的值为 3，正如所料。但如果你试着更改 A0 或 A1，你会注意到 A2 也随即自动更新了。

而 JavaScript 默认并不是这样的。如果我们用 JavaScript 写类似的逻辑

```js
let A0 = 1
let A1 = 2
let A2 = A0 + A1

console.log(A2) // 3

A0 = 2
console.log(A2) // 仍然是 3
```

我们无法直接追踪对上述示例中局部变量的读写，原生 JavaScript 没有提供任何机制能做到这一点。但是，我们是可以**追踪对象属性的读写**的。

### Vue2中响应式的实现

vue2中响应式的实现核心api：`Object.defineProperty`

1、监听属性的读写 

[Object.defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

```js
// obj：要定义属性的对象
// prop：要定义或修改的属性的名称
// descriptor：要定义或修改的属性描述符
Object.defineProperty(obj, prop, descriptor)
```

```js
function updateView(){
  console.log("视图更新");
}

function defineReactive(target, key, value) {
  
  Object.defineProperty(target, key, {
    get() {
      console.log('监听到读')
      return value
    },
    set(newValue) {
      console.log('监听到写')
      if(newValue !== value) {
        value = newValue
        updateView()
      }
    }
  })
}


function observe(target){
  if(typeof target !== 'object' || target === null) {
    return target;
  }

  // 将对象的属性用 defineProperty 重新定义
  for(let key in target) {
    defineReactive(target, key, target[key])
  }
}

let data = {
  name: 'will',
  age: 25,
  job: 'FE',
  likes: ['basketball', 'football', 'swimming'],
  relate: {
    father: 'will father',
    son: 'will son'
  }
}

observe(data)


data.name = 'will wong' // 监听到写 ->  视图更新

data.likes[2] = 'tennis' //  ❌ 无法监听到写，视图未更新 

data.relate.son = 'will wong son' //  ❌ 无法监听到写，视图未更新

```

2、视图更新优化（实现对象深度监听）

**因为考虑性能问题实际上，vue没有这么做。因为不确定数组的长度，对数组遍历进行劫持性能会损失很大**，vue而是提供了 Vue.vue方法 来解决数组和深对象的响应式问题。

```js{3}
function defineReactive(target, key, value) {

  observe(value)
  
  Object.defineProperty(target, key, {
    get() {
      console.log('监听到读')
      return value
    },
    set(newValue) {
      console.log('监听到写')
      if(newValue !== value) {
        value = newValue
        updateView()
      }
    }
  })
}

data.name = 'will wong' // 监听到写 ->  视图更新

data.likes[2] = 'tennis' //  监听到读和写 ->  视图更新 

data.relate.son = 'will wong son' //   监听到读和写 ->  视图更新 

```

### Vue2 $set()方法实现原理

set 方法主要作用是向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，对象不能是 Vue 实例，或者 Vue 实例的根数据对象。

```
Vue.set( target, key, value ) / this.$set( target, key, value )
target：要更改的数据源(可以是对象或者数组)
key：要更改的具体数据，或者新增的属性名
value ：重新赋的值
```

1、如果是 undefined 、null 、基本数据类型，直接报错;

2、如果为数组，取当前数组长度与 key 这两者的最大值作为数组的新长度，然后使用数组的 splice 方法将传入的索引 key 对应的 val 值添加进数组。target 在 observe 的时候，原型链被修改了， splice 方法也已经被重写了，触发之后会再次遍历数组，进行数据劫持，也就是说当使用 splice 方法向数组内添加元素时，该元素会自动被变成响应式的

3、如果为对象，会先判断 key 值是否存在于对象中，如果在，则直接替换 value。如果不在，就判断 target 是不是响应式对象（其实就是判断它是否有 __ob__ 属性），接着判断如果它是不是 Vue 实例，或者是 Vue 实例的根数据对象，如果是则抛出警告并退出程序。如果 target 不是响应式对象，就直接给 target 的 key 赋值，如果 target 是响应式对象，就调用 defineReactive 将新属性的值添加到 target 上，并进行依赖收集，更新视图

```js
function set(target: Array<any> | Object, key: any, val: any): any {
  // isUndef 是判断 target 是不是等于 undefined 或者 null 。
  // isPrimitive 是判断 target 的数据类型是不是 string、number、symbol、boolean 中的一种
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }

  // 数组的处理
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }

  // 对象，并且该属性原来已存在于对象中，则直接更新
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }

  // vue给响应式对象(比如 data 里定义的对象)都加了一个 __ob__ 属性，
  // 如果一个对象有这个 __ob__ 属性，那么就说明这个对象是响应式对象，修改对象已有属性的时候就会触发页面渲染
  // 非 data 里定义的就不是响应式对象。
  const ob = (target: any).__ob__

  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }

  // 不是响应式对象
  if (!ob) {
    target[key] = val
    return val
  }

  // 是响应式对象，进行依赖收集
  defineReactive(ob.value, key, val)

  // 触发更新视图
  ob.dep.notify()
  return val
}

```

### Vue3中的响应式

在 Vue 3 中则使用了 Proxy 来创建响应式对象，仅将 getter / setter 用于 ref。下面的伪代码将会说明它们是如何工作的

```js
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key)
      return target[key]
    },
    set(target, key, value) {
      target[key] = value
      trigger(target, key)
    }
  })
}

function ref(value) {
  const refObject = {
    get value() {
      track(refObject, 'value')
      return value
    },
    set value(newValue) {
      value = newValue
      trigger(refObject, 'value')
    }
  }
  return refObject
}

```

先理解 Proxy

> Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

```js
// 代理整个对象，从而侦测数据变化
function defineReactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      console.log("get", key);
      return target[key]    
    },
    set(target, key, val) {
      console.log("set", key);
      target[key] =val
      update()    
    }  
  })
}
function update() {
  console.log(obj.a);
}

// test
const obj= {}
const observed = defineReactive(obj)
observed.a='前端'

```

## 说说事件委托

**事件委托**，也可以叫做事件代理，利用了事件冒泡的原理来优化事件处理。事件委托允许你不必直接在目标元素上绑定事件处理器，而是在其父元素上设置单一的事件处理器来管理所有子元素的相应事件。

举个例子，现在有100个按钮，循环给每个按钮添加点击事件，那么会增加内存损耗，影响性能。此时可以给button的父元素添加点击事件，这时相当于每个按钮都绑定了点击事件。这里就涉及到了 事件冒泡的原理了。

**事件冒泡**，当我们给子元素和父元素都绑定了click事件时，点击子元素，父元素的click事件也会被触发，这就是事件冒泡。当我们子元素没有绑定click事件，但是父元素绑定了click事件，当我们点击子元素时，由于事件冒泡，我们会将这个事件e传递给父元素，父元素也会触发click事件。

``` html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .container {
      width: 600px;
      height: 600px;
      border: 1px solid #000;
      display: flex;
      flex-wrap: wrap;
    }

    .item {
      width: 100px;
      height: 100px;
      background-color: slategray;
      margin-right: 10px;
      margin-bottom: 10px;
    }
  </style>
</head>



<body>
  <div class="container" id="container">
    <div class="item" id="btn1"></div>
    <div class="item" id="btn2"></div>
    <div class="item" id="btn3"></div>
    <div class="item" id="btn4"></div>
    <div class="item" id="btn5"></div>
    <div class="item" id="btn6"></div>
    <div class="item" id="btn7"></div>
    <div class="item" id="btn8"></div>
    <div class="item" id="btn9"></div>
  </div>
</body>

<script>
  const container = document.getElementById('container')
  container.addEventListener('click', function(event){
    console.log(event.target.id) // btn1、btn2 、btn3 ……
  })
</script>

</html>

```




## 常见的页面布局

参考[常见的布局](https://heptaluan.github.io/2019/09/12/CSS/11/)


## css 权重

```
!important > 行内样式 > ID选择器 > 类选择器 | 属性选择器 | 伪类选择器 > 元素选择器
```

权重规则总结:

1、!important 优先级最高，但也会被权重高的!important所覆盖
2、行内样式总会覆盖外部样式表的任何样式(除了!important)

3、单独使用一个选择器的时候，不能跨等级使css规则生效

例如： 无论多少个class组成的选择器，都没有一个ID选择器权重高 

4、如果两个权重不同的选择器作用在同一元素上，权重值高的css规则生效
5、如果两个相同权重的选择器作用在同一元素上：以后面出现的选择器为最后规则.
6、权重相同时，与元素距离近的选择器生效


其中通配符选择器 *，组合选择器 + ~ >，否定伪类选择器 :not() 对优先级无影响

> 通配符 *	权重固定为 0-0-0，
> 组合符 +, ~, > 仅描述元素关系，不参与权重计算
> 否定伪类 :not() 本身不增加权重，但括号内的选择器会正常计算优先级

建议：
- 避免使用!important;
- 利用id增加选择器权重;
- 减少选择器的个数（避免层层嵌套）;

参考[你对CSS权重真的足够了解吗？](https://juejin.cn/post/6844903608199151630)

## ’+’ 与 ’~’ 选择器有什么不同

```
+ 选择器匹配紧邻的兄弟元素

~ 选择器匹配随后的所有兄弟元素
```

## z-index 与层叠上下文

z-index用于设置元素的堆叠顺序，而层叠上下文则是决定这些z-index值如何相互作用的环境。

层叠上下文是一个三维的概念，它决定了页面中一组元素的堆叠顺序。每个层叠上下文都有自己的z-index层级，层叠上下文内的元素只会与同一上下文中的其他元素进行z-index比较，这也导致了z-index小的可能在z-index大的元素上。

## 实现水平垂直居中

需要考虑元素固定宽高和不定宽高，行内或者块状

1、绝对定位的方法

- 绝对定位 + transform

```css
.box {
  postion: absolute;
  top: 50%;
  bottom: 50%;
  width: 100px;
  height: 100px;
  transform: translate(-50%, -50%);
}
```

- 绝对定位 + 负margin

缺点：需要知道box的宽高

```css
.wp {
    position: relative;
}
.box {
    position: absolute;;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
}
```

- 绝对定位，四个方向都写0
```css
.container {
  position: relative;
  height: 300px;
  border: 1px solid red;
}
.item {
  width: 100px;
  height: 50px;
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  margin: auto;
  border: 1px solid green;
}
```

2、flex布局法

```css
.box {
  display: flex;
}
.item {
  margin: auto;
}
```

