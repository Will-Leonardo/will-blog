---
title: web前端面试知识点
date: 2024-11-25
categories: 
 - 前端基础
---
<Boxx type='tip' />

## 说说你对vue的理解

Vue是目前国内比较流行的用于构建用户界面的javascript
框架，有易学易用，性能出色，灵活多变的特点。它的设计哲学是渐进式的，他只关注视图层，通过配合使用其他库和工具（例如： vue-router、vuex、Typescript等），它也能够帮助开发者构建复杂的前端应用。它的要素在于 *响应式系统、组件化、模版语法、虚拟dom*、有健全的工具链和生态系统，社区文档都比较齐全。

- 响应式系统：Vue通过使用响应式系统自动追踪依赖和管理DOM更新。当模型状态改变时，视图会自动更新，这使得状态管理变得简单高效。
- 组件化：Vue鼓励开发者通过组件化的方式构建应用，每个组件都有自己的视图、数据逻辑和样式，这样有助于提高代码的复用性和测试性。
- 模板语法：Vue使用基于HTML的模板语法，允许开发者声明式地将DOM绑定到底层Vue实例的数据上。模板支持数据绑定、指令（如v-if、v-for等）、事件处理等。
- 虚拟DOM：Vue使用虚拟DOM来优化DOM的更新，通过计算前后两次数据变化产生的差异，然后高效地批量更新DOM，而不是直接操作DOM。

## 那你讲讲Vue的响应式

- [深入响应式原理](https://v2.cn.vuejs.org/v2/guide/reactivity.html)
- [深入响应式系统](https://v2.cn.vuejs.org/v2/guide/reactivity.html)

*首先什么是响应式？*

个经常被拿来当作典型例子的用例即是 Excel 表格：
单元格 A2 中的值是通过公式 = A0 + A1 来定义的 (你可以在 A2 上点击来查看或编辑该公式)，因此最终得到的值为 3，正如所料。但如果你试着更改 A0 或 A1，你会注意到 A2 也随即自动更新了。

而 JavaScript 默认并不是这样的。如果我们用 JavaScript 写类似的逻辑

```js
let A0 = 1
let A1 = 2
let A2 = A0 + A1

console.log(A2) // 3

A0 = 2
console.log(A2) // 仍然是 3
```

我们无法直接追踪对上述示例中局部变量的读写，原生 JavaScript 没有提供任何机制能做到这一点。但是，我们是可以追踪**对象属性**的读写的。

### Vue2中响应式的实现

- [ ] 这里只简单的写了一下，后续在细细研究

vue2中响应式的实现核心api：`Object.defineProperty`

1、监听属性的读写 

```js
function updateView(){
  console.log("视图更新");
}

function defineReactive(target, key, value) {
  
  Object.defineProperty(target, key, {
    get() {
      console.log('监听到读')
      return value
    },
    set(newValue) {
      console.log('监听到写')
      if(newValue !== value) {
        value = newValue
        updateView()
      }
    }
  })
}


function observe(target){
  if(typeof target !== 'object' || target === null) {
    return target;
  }

  // 将对象的属性用 defineProperty 重新定义
  for(let key in target) {
    defineReactive(target, key, target[key])
  }
}

let data = {
  name: 'will',
  age: 25,
  job: 'FE',
  likes: ['basketball', 'football', 'swimming'],
  relate: {
    father: 'will father',
    son: 'will son'
  }
}

observe(data)


data.name = 'will wong' // 监听到写 ->  视图更新

data.likes[2] = 'tennis' //  ❌ 无法监听到写，视图未更新 

data.relate.son = 'will wong son' //  ❌ 无法监听到写，视图未更新

```

2、视图更新优化（实现对象深度监听）

**因为考虑性能问题实际上，vue没有这么做。因为不确定数组的长度，对数组遍历进行劫持性能会损失很大**，vue而是提供了 Vue.vue方法 来解决数组和深对象的响应式问题。

```js{3}
function defineReactive(target, key, value) {

  observe(value)
  
  Object.defineProperty(target, key, {
    get() {
      console.log('监听到读')
      return value
    },
    set(newValue) {
      console.log('监听到写')
      if(newValue !== value) {
        value = newValue
        updateView()
      }
    }
  })
}

data.name = 'will wong' // 监听到写 ->  视图更新

data.likes[2] = 'tennis' //  监听到读和写 ->  视图更新 

data.relate.son = 'will wong son' //   监听到读和写 ->  视图更新 

```

### Vue2 $set()方法实现原理

set 方法主要作用是向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，对象不能是 Vue 实例，或者 Vue 实例的根数据对象。

```
Vue.set( target, key, value ) / this.$set( target, key, value )
target：要更改的数据源(可以是对象或者数组)
key：要更改的具体数据，或者新增的属性名
value ：重新赋的值
```

1、如果是 undefined 、null 、基本数据类型，直接报错;

2、如果为数组，取当前数组长度与 key 这两者的最大值作为数组的新长度，然后使用数组的 splice 方法将传入的索引 key 对应的 val 值添加进数组。target 在 observe 的时候，原型链被修改了， splice 方法也已经被重写了，触发之后会再次遍历数组，进行数据劫持，也就是说当使用 splice 方法向数组内添加元素时，该元素会自动被变成响应式的

3、如果为对象，会先判断 key 值是否存在于对象中，如果在，则直接替换 value。如果不在，就判断 target 是不是响应式对象（其实就是判断它是否有 __ob__ 属性），接着判断如果它是不是 Vue 实例，或者是 Vue 实例的根数据对象，如果是则抛出警告并退出程序。如果 target 不是响应式对象，就直接给 target 的 key 赋值，如果 target 是响应式对象，就调用 defineReactive 将新属性的值添加到 target 上，并进行依赖收集，更新视图

```js
function set(target: Array<any> | Object, key: any, val: any): any {
  // isUndef 是判断 target 是不是等于 undefined 或者 null 。
  // isPrimitive 是判断 target 的数据类型是不是 string、number、symbol、boolean 中的一种
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }

  // 数组的处理
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }

  // 对象，并且该属性原来已存在于对象中，则直接更新
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }

  // vue给响应式对象(比如 data 里定义的对象)都加了一个 __ob__ 属性，
  // 如果一个对象有这个 __ob__ 属性，那么就说明这个对象是响应式对象，修改对象已有属性的时候就会触发页面渲染
  // 非 data 里定义的就不是响应式对象。
  const ob = (target: any).__ob__

  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }

  // 不是响应式对象
  if (!ob) {
    target[key] = val
    return val
  }

  // 是响应式对象，进行依赖收集
  defineReactive(ob.value, key, val)

  // 触发更新视图
  ob.dep.notify()
  return val
}

```

### Vue3中的响应式

在 Vue 3 中则使用了 Proxy 来创建响应式对象，仅将 getter / setter 用于 ref。下面的伪代码将会说明它们是如何工作的

```js
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key)
      return target[key]
    },
    set(target, key, value) {
      target[key] = value
      trigger(target, key)
    }
  })
}

function ref(value) {
  const refObject = {
    get value() {
      track(refObject, 'value')
      return value
    },
    set value(newValue) {
      value = newValue
      trigger(refObject, 'value')
    }
  }
  return refObject
}

```

先理解 Proxy

> Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

```js
// 代理整个对象，从而侦测数据变化
function defineReactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      console.log("get", key);
      return target[key]    
    },
    set(target, key, val) {
      console.log("set", key);
      target[key] =val
      update()    
    }  
  })
}
function update() {
  console.log(obj.a);
}

// test
const obj= {}
const observed = defineReactive(obj)
observed.a='前端'

```

## 


