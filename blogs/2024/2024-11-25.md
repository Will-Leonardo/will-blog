---
title: web前端面试知识点
date: 2024-11-25
categories: 
 - 前端基础
sticky: 1
---
<Boxx type='tip' />

## 说说你对vue的理解

Vue是目前国内比较流行的用于**构建用户界面**的javascript框架，有易学易用，性能出色，灵活多变的特点。它的设计哲学是渐进式的，关注视图层，配合使用其他库和工具（例如： vue-router、vuex、Typescript等），它也能够帮助开发者构建复杂的前端应用。它的要素在于 *响应式系统、组件化、模版语法、虚拟dom*、有健全的工具链和生态系统，社区文档都比较齐全。

- 响应式系统：Vue通过使用响应式系统自动追踪依赖和管理DOM更新。当模型状态改变时，视图会自动更新，这使得状态管理变得简单高效。
- 组件化：Vue鼓励开发者通过组件化的方式构建应用，每个组件都有自己的视图、数据逻辑和样式，这样有助于提高代码的复用性和测试性。
- 模板语法：Vue使用基于HTML的模板语法，允许开发者声明式地将DOM绑定到底层Vue实例的数据上。模板支持数据绑定、指令（如v-if、v-for等）、事件处理等。
- 虚拟DOM：Vue使用虚拟DOM来优化DOM的更新，通过计算前后两次数据变化产生的差异，然后高效地批量更新DOM，而不是直接操作DOM。

## 那你讲讲Vue的响应式

- [深入响应式原理](https://v2.cn.vuejs.org/v2/guide/reactivity.html)
- [深入响应式系统](https://v2.cn.vuejs.org/v2/guide/reactivity.html)

*首先什么是响应式？*

个经常被拿来当作典型例子的用例即是 Excel 表格：
单元格 A2 中的值是通过公式 = A0 + A1 来定义的 (你可以在 A2 上点击来查看或编辑该公式)，因此最终得到的值为 3，正如所料。但如果你试着更改 A0 或 A1，你会注意到 A2 也随即自动更新了。

而 JavaScript 默认并不是这样的。如果我们用 JavaScript 写类似的逻辑

```js
let A0 = 1
let A1 = 2
let A2 = A0 + A1

console.log(A2) // 3

A0 = 2
console.log(A2) // 仍然是 3
```

我们无法直接追踪对上述示例中局部变量的读写，原生 JavaScript 没有提供任何机制能做到这一点。但是，我们是可以**追踪对象属性的读写**的。

### Vue2中响应式的实现

vue2中响应式的实现核心api：`Object.defineProperty`

1、监听属性的读写 

[Object.defineProperty](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)

```js
// obj：要定义属性的对象
// prop：要定义或修改的属性的名称
// descriptor：要定义或修改的属性描述符
Object.defineProperty(obj, prop, descriptor)
```

```js
function updateView(){
  console.log("视图更新");
}

function defineReactive(target, key, value) {
  
  Object.defineProperty(target, key, {
    get() {
      console.log('监听到读')
      return value
    },
    set(newValue) {
      console.log('监听到写')
      if(newValue !== value) {
        value = newValue
        updateView()
      }
    }
  })
}


function observe(target){
  if(typeof target !== 'object' || target === null) {
    return target;
  }

  // 将对象的属性用 defineProperty 重新定义
  for(let key in target) {
    defineReactive(target, key, target[key])
  }
}

let data = {
  name: 'will',
  age: 25,
  job: 'FE',
  likes: ['basketball', 'football', 'swimming'],
  relate: {
    father: 'will father',
    son: 'will son'
  }
}

observe(data)


data.name = 'will wong' // 监听到写 ->  视图更新

data.likes[2] = 'tennis' //  ❌ 无法监听到写，视图未更新 

data.relate.son = 'will wong son' //  ❌ 无法监听到写，视图未更新

```

2、视图更新优化（实现对象深度监听）

**因为考虑性能问题实际上，vue没有这么做。因为不确定数组的长度，对数组遍历进行劫持性能会损失很大**，vue而是提供了 Vue.vue方法 来解决数组和深对象的响应式问题。

```js{3}
function defineReactive(target, key, value) {

  observe(value)
  
  Object.defineProperty(target, key, {
    get() {
      console.log('监听到读')
      return value
    },
    set(newValue) {
      console.log('监听到写')
      if(newValue !== value) {
        value = newValue
        updateView()
      }
    }
  })
}

data.name = 'will wong' // 监听到写 ->  视图更新

data.likes[2] = 'tennis' //  监听到读和写 ->  视图更新 

data.relate.son = 'will wong son' //   监听到读和写 ->  视图更新 

```

### Vue2 $set()方法实现原理

set 方法主要作用是向响应式对象中添加一个属性，并确保这个新属性同样是响应式的，且触发视图更新。它必须用于向响应式对象上添加新属性，对象不能是 Vue 实例，或者 Vue 实例的根数据对象。

```
Vue.set( target, key, value ) / this.$set( target, key, value )
target：要更改的数据源(可以是对象或者数组)
key：要更改的具体数据，或者新增的属性名
value ：重新赋的值
```

1、如果是 undefined 、null 、基本数据类型，直接报错;

2、如果为数组，取当前数组长度与 key 这两者的最大值作为数组的新长度，然后使用数组的 splice 方法将传入的索引 key 对应的 val 值添加进数组。target 在 observe 的时候，原型链被修改了， splice 方法也已经被重写了，触发之后会再次遍历数组，进行数据劫持，也就是说当使用 splice 方法向数组内添加元素时，该元素会自动被变成响应式的

3、如果为对象，会先判断 key 值是否存在于对象中，如果在，则直接替换 value。如果不在，就判断 target 是不是响应式对象（其实就是判断它是否有 __ob__ 属性），接着判断如果它是不是 Vue 实例，或者是 Vue 实例的根数据对象，如果是则抛出警告并退出程序。如果 target 不是响应式对象，就直接给 target 的 key 赋值，如果 target 是响应式对象，就调用 defineReactive 将新属性的值添加到 target 上，并进行依赖收集，更新视图

```js
function set(target: Array<any> | Object, key: any, val: any): any {
  // isUndef 是判断 target 是不是等于 undefined 或者 null 。
  // isPrimitive 是判断 target 的数据类型是不是 string、number、symbol、boolean 中的一种
  if (process.env.NODE_ENV !== 'production' &&
    (isUndef(target) || isPrimitive(target))
  ) {
    warn(`Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}`)
  }

  // 数组的处理
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key)
    target.splice(key, 1, val)
    return val
  }

  // 对象，并且该属性原来已存在于对象中，则直接更新
  if (key in target && !(key in Object.prototype)) {
    target[key] = val
    return val
  }

  // vue给响应式对象(比如 data 里定义的对象)都加了一个 __ob__ 属性，
  // 如果一个对象有这个 __ob__ 属性，那么就说明这个对象是响应式对象，修改对象已有属性的时候就会触发页面渲染
  // 非 data 里定义的就不是响应式对象。
  const ob = (target: any).__ob__

  if (target._isVue || (ob && ob.vmCount)) {
    process.env.NODE_ENV !== 'production' && warn(
      'Avoid adding reactive properties to a Vue instance or its root $data ' +
      'at runtime - declare it upfront in the data option.'
    )
    return val
  }

  // 不是响应式对象
  if (!ob) {
    target[key] = val
    return val
  }

  // 是响应式对象，进行依赖收集
  defineReactive(ob.value, key, val)

  // 触发更新视图
  ob.dep.notify()
  return val
}

```

### Vue3中的响应式

在 Vue 3 中则使用了 Proxy 来创建响应式对象，仅将 getter / setter 用于 ref。下面的伪代码将会说明它们是如何工作的

```js
function reactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      track(target, key)
      return target[key]
    },
    set(target, key, value) {
      target[key] = value
      trigger(target, key)
    }
  })
}

function ref(value) {
  const refObject = {
    get value() {
      track(refObject, 'value')
      return value
    },
    set value(newValue) {
      value = newValue
      trigger(refObject, 'value')
    }
  }
  return refObject
}

```

先理解 Proxy

> Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。

```js
// 代理整个对象，从而侦测数据变化
function defineReactive(obj) {
  return new Proxy(obj, {
    get(target, key) {
      console.log("get", key);
      return target[key]    
    },
    set(target, key, val) {
      console.log("set", key);
      target[key] =val
      update()    
    }  
  })
}
function update() {
  console.log(obj.a);
}

// test
const obj= {}
const observed = defineReactive(obj)
observed.a='前端'

```

## 说说事件委托

**事件委托**，也可以叫做事件代理，利用了事件冒泡的原理来优化事件处理。事件委托允许你不必直接在目标元素上绑定事件处理器，而是在其父元素上设置单一的事件处理器来管理所有子元素的相应事件。

举个例子，现在有100个按钮，循环给每个按钮添加点击事件，那么会增加内存损耗，影响性能。此时可以给button的父元素添加点击事件，这时相当于每个按钮都绑定了点击事件。这里就涉及到了 事件冒泡的原理了。

**事件冒泡**，当我们给子元素和父元素都绑定了click事件时，点击子元素，父元素的click事件也会被触发，这就是事件冒泡。当我们子元素没有绑定click事件，但是父元素绑定了click事件，当我们点击子元素时，由于事件冒泡，我们会将这个事件e传递给父元素，父元素也会触发click事件。

``` html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    .container {
      width: 600px;
      height: 600px;
      border: 1px solid #000;
      display: flex;
      flex-wrap: wrap;
    }

    .item {
      width: 100px;
      height: 100px;
      background-color: slategray;
      margin-right: 10px;
      margin-bottom: 10px;
    }
  </style>
</head>



<body>
  <div class="container" id="container">
    <div class="item" id="btn1"></div>
    <div class="item" id="btn2"></div>
    <div class="item" id="btn3"></div>
    <div class="item" id="btn4"></div>
    <div class="item" id="btn5"></div>
    <div class="item" id="btn6"></div>
    <div class="item" id="btn7"></div>
    <div class="item" id="btn8"></div>
    <div class="item" id="btn9"></div>
  </div>
</body>

<script>
  const container = document.getElementById('container')
  container.addEventListener('click', function(event){
    console.log(event.target.id) // btn1、btn2 、btn3 ……
  })
</script>

</html>

```




## 常见的页面布局

参考[常见的布局](https://heptaluan.github.io/2019/09/12/CSS/11/)


## css 权重

```
!important > 行内样式 > ID选择器 > 类选择器 | 属性选择器 | 伪类选择器 > 元素选择器
```

权重规则总结:

1、!important 优先级最高，但也会被权重高的!important所覆盖
2、行内样式总会覆盖外部样式表的任何样式(除了!important)

3、单独使用一个选择器的时候，不能跨等级使css规则生效

例如： 无论多少个class组成的选择器，都没有一个ID选择器权重高 

4、如果两个权重不同的选择器作用在同一元素上，权重值高的css规则生效
5、如果两个相同权重的选择器作用在同一元素上：以后面出现的选择器为最后规则.
6、权重相同时，与元素距离近的选择器生效


其中通配符选择器 *，组合选择器 + ~ >，否定伪类选择器 :not() 对优先级无影响

> 通配符 *	权重固定为 0-0-0，
> 组合符 +, ~, > 仅描述元素关系，不参与权重计算
> 否定伪类 :not() 本身不增加权重，但括号内的选择器会正常计算优先级

建议：
- 避免使用!important;
- 利用id增加选择器权重;
- 减少选择器的个数（避免层层嵌套）;

参考[你对CSS权重真的足够了解吗？](https://juejin.cn/post/6844903608199151630)

## ’+’ 与 ’~’ 选择器有什么不同

```
+ 选择器匹配紧邻的兄弟元素

~ 选择器匹配随后的所有兄弟元素
```

## z-index 与层叠上下文

z-index用于设置元素的堆叠顺序，而层叠上下文则是决定这些z-index值如何相互作用的环境。

层叠上下文是一个三维的概念，它决定了页面中一组元素的堆叠顺序。每个层叠上下文都有自己的z-index层级，层叠上下文内的元素只会与同一上下文中的其他元素进行z-index比较，这也导致了z-index小的可能在z-index大的元素上。

## 实现水平垂直居中

需要考虑元素固定宽高和不定宽高，行内或者块状

1、绝对定位的方法

- 绝对定位 + transform

```css
.box {
  postion: absolute;
  top: 50%;
  bottom: 50%;
  width: 100px;
  height: 100px;
  transform: translate(-50%, -50%);
}
```

- 绝对定位 + 负margin

缺点：需要知道box的宽高

```css
.wp {
    position: relative;
}
.box {
    position: absolute;;
    top: 50%;
    left: 50%;
    margin-left: -50px;
    margin-top: -50px;
}
```

- 绝对定位，四个方向都写0
```css
.container {
  position: relative;
  height: 300px;
  border: 1px solid red;
}
.item {
  width: 100px;
  height: 50px;
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  margin: auto;
  border: 1px solid green;
}
```

2、flex布局法

```css
.box {
  display: flex;
}
.item {
  margin: auto;
}
```



## javascript部分


### 常见的手写题

参考： https://juejin.cn/post/7031322059414175774?utm_source=gold_browser_extension 


#### 1、防抖
防抖好比法师发动技能，每次都要重新蓄力读条，进度条100%才会发出。（有点像回城）

直接调用原函数肯定无法实现防抖的效果，所以需要构建一个新函数，所以我们这个debounce函数接收两个参数，第一个参数是原函数，第二个参数是延迟时间，返回的是一个（新）函数，使用时调用新函数，就会实现防抖效果。调用新函数时，怎么做到每点发动技能都要重新蓄力呢？在函数中设置一个定时器，在定时器结束之后才调用原函数，执行函数时先检查有没有之前的计时器，有的话就清除，重新计时。记住，这个timer需要定义在这个新函数的外层，因为每次调用新函数时，这个timer都需要时同一个，而不是重新创建的，最后需要考虑函数的this指向和参数传递。

```js
function debounce(fn, delay) {
  let timer
  return function (...args) {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// 测试
function scrolling(a,b) {
  console.log('is scrolling', a, b)
}
const debounceTask = debounce(scrolling, 1000)
window.addEventListener('scroll', debounceTask('1','2'))
```

#### 2、节流
节流好比fps射击游戏，你手速再快也会枪械射速的限制，单位时间内只会射出一颗子弹。

```js

function throttle(fn, delay) {
  let last = 0; // 上次触发的时间戳
  return (...args ) => {
    let now = Date.now()
    if(now - last > delay) {
      last = now
      fn.apply(this, args)
    }
  }
}

// 测试
function scrolling() {
  console.log('is scrolling')
}
const throttleTask = throttle(scrolling, 1000)
window.addEventListener('scroll', throttleTask)
```

:::details 防抖和节流的场景
- 防抖：搜索输入框、窗口大小调整、按钮提交等

- 节流：滚动事件处理、滚动事件的懒加载
:::

#### 3、深拷贝

深拷贝是指将原对象或数组的值复制到一个新的对象或数组中，并且新的对象或数组的属性或元素完全独立于原对象或数组，即它们不共享引用地址。因此，当我们修改其中一个对象或数组时，另一个对象或数组不会受到任何影响。

```js
// 不支持值为undefined、函数和循环引用的情况
const cloneObj = JSON.parse(JSON.stringify(obj))
```

递归实现
```js
const deepClone = (obj, cache = new WeakMap()) => {
  // 非引用类型 返回原值，注意 type null === 'object' 是js的历史缺陷
  if(obj === null || typeof obj !== 'object') return obj;
  if(obj instanceof Date) return new Date(obj)
  if(obj instanceof RegExp) return new RegExp(obj)

  // 如果出现循环引用，则返回缓存的对象，防止递归进入死循环
  if(cache.has(obj)) return cache.get(obj)

  let cloneObj = obj.constructor()
  cache.set(obj, cloneObj)

  for(let key in obj) {
    if(obj.hasOwnProperty(key)) { // 只克隆自身的属性，不克隆原型链上的属性
      cloneObj[key] = deepClone(obj[key], cache)
    }
  }

  return cloneObj
}

const a = { name: 'will', score: { english: '150', math: '150' } }

const b = deepClone(a)

console.log(b)
```

::: details 常使用的浅拷贝和深拷贝

- 浅拷贝：

浅拷贝，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝

如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址

即浅拷贝是拷贝一层，深层次的引用类型则共享内存地址

需要理解这里的一层的意思，例如拷贝：`const  arr = [1,2,3,4] `和`const arr = [{ name: will }]`

1. `Object.assign()`
2. `cons arr1 = [...arr]` 拓展运算符
3. `Array.prototype.slice()`
4. `Array.prototype.concat()`


- 深拷贝：
1. `JSON.parse(JSON.stringify(obj))` // 弊端会忽略undefined、symbol和函数
2. `lodash.cloneDeep()`

:::



#### 4、手写 Function.prototype.call() \ apply() \ bind()

```js
var name = "lucy";
var obj = {
    name: "martin",
    say: function () {
        console.log(this.name);
    }
};
obj.say(); // martin，this 指向 obj 对象
setTimeout(obj.say,0); // lucy，this 指向 window 对象
```

`call `方法的作用是 改变函数执行时的 this 指向

::: details 大白话讲this
在 JavaScript 中，this 就像是一个指针，它指向"谁在调用当前代码"。简单来说，this 就是函数运行时的上下文，也就是这个函数是"谁"在执行。举例：

想象你是一名服务员，你说："我来为您服务"。这里的"我"就相当于 JavaScript 中的 this，它指的是"谁在说这句话"。
如果是张三在说，那么"我"就是张三
如果是李四在说，那么"我"就是李四
:::


```js {8}
Function.prototype.myCall = function(context, ...args) {
  context = context || window; // 如果没有传入context，则默认指向全局对象

  const fnSymbol = Symbol('fn'); // 创建一个唯一的属性名，避免冲突
  context[fnSymbol] = this; // 将函数作为context的一个属性

  // 这一步是关键，因为当一个函数作为对象的方法调用时，this 会指向该对象
  const result = context[fnSymbol](...args); 
  delete context[fnSymbol]; // 删除这个属性，避免污染context
  return result; // 返回函数执行的结果
}
```

```js
Function.prototype.myApply = function (context, args) {
  context = context || window;
  const fn = symbol('fn');
  context[fn] = this;
  let result;
  
  if(!args) {
    result = context[fn]();
  } else {
    if(!Array.isArray(args)) {
      throw new TypeError('args must be an array');
    }
    result = context[fn](...args);
  }

  delete context[fn];
  return result;
}
```

```js
Function.prototype.myBind = function (context, ...args) {
  // 保存原始函数的引用
  const originalFunc = this;
  context = context || (typeof window !== 'undefined' ? window : global);
  const boundFunc = function (..args2) {
    // 合并参数
    const allArgs = [...args, ...args2];
    // 处理构造函数的情况
    // 如果是通过 new 调用，this 应该指向新创建的对象（即 boundFunc 的实例）
    // 否则，this 应该指向 context
    return originalFunc.apply(
      this instanceof boundFunc ? this : context,
      allArgs
    );
  }

  // 设置原型链，使得通过 new 调用时能够继承原始函数的原型
  // 创建一个空函数作为中介，避免直接修改原始函数的原型
  const EmptyFunc = function () {};
  EmptyFunc.prototype = originalFunc.prototype;
  boundFunc.prototype = new EmptyFunc();

  return boundFunc
}

```




#### 5、手写promise

Promise 用大白话来说就是一个"承诺"，它代表了一个异步操作的最终结果。当我们进行异步操作时（比如网络请求、文件读取等），不能立即得到结果，Promise 就像是一张"欠条"，承诺在未来某个时刻给你一个结果。

Promise 有三种状态：

- pending（等待中）：初始状态，既没有成功也没有失败
- fulfilled（已成功）：操作成功完成
- rejected（已失败）：操作失败

Promise 一旦状态改变（从 pending 变为 fulfilled 或 rejected），就不会再变，这个结果是固定的。

参考：[手写Promise](https://juejin.cn/post/6850037281206566919), 推荐阅读，一步一步的实现

```js
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

class Promise {
  constructor(executor) {
    // 初始状态为 pending
    this.status = PENDING;
    // 成功的值
    this.value = undefined;
    // 失败的原因
    this.reason = undefined;
    // 成功的回调函数队列
    this.onFulfilledCallbacks = [];
    // 失败的回调函数队列
    this.onRejectedCallbacks = [];

    const resolve = (value) => {
      // 只有在 pending 状态才能转变为 fulfilled
      // 防止 executor 中调用了两次 resovle/reject 方法
      if (this.status === PENDING) {
        this.status = FULFILLED;
        this.value = value;
        this.onFulfilledCallbacks.forEach(fn => fn());
      }
    }

    const reject = (reason) => {
      // 只有在 pending 状态才能转变为 rejected
      // 防止 executor 中调用了两次 resovle/reject 方法
      if (this.status === PENDING) {
        this.status = REJECTED;
        this.reason = reason;
        // 执行失败的回调
        this.onRejectedCallbacks.forEach(fn => fn());
      }
    };

    try {
      // 立即执行
      executor(resolve, reject);
    } catch(error) {
      // 如果executor执行出错，直接reject
      reject(error);
    }
  };

  then(onFulfilled, onRejected) { 
    // 参数可选，如果不是函数，则 v => v 是为了值可以继续往下传
    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : v => v;
    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason };

    // 创建一个新的Promise2，用于链式调用
    const promise2 = new MyPromise((resolve, reject) => {
      // （这里是成层的promise完成，并且成功）成功状态处理
      if(this.status === FULFILLED) {
        setTimeout(() => {
          try {
            const x = onFulfilled(this.value);
            // 这里需要继续处理x，是因为x可能是一个promise
            this.resolvePromise(promise2, x, resolve, reject);
          } catch (error) {
            reject(error);
          }
        },0)
      }
      // 失败状态处理
      if(this.status === REJECTED) {
        setTimeout(() => {
          try {
            const x = onRejected(this.reason);
            this.resolvePromise(promise2, x, resolve, reject);
          }
        }, 0)
      }
      // pending状态处理
      if(this.status === PENDING) {
        // 将回调存入队列，等待状态改变时执行
        this.onFulfilledCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onFulfilled(this.value);
              this.resolvePromise(promise2, x, resolve, reject);
            } catch (error) {
              reject(error);
            }
          })
        })

        this.onRejectedCallbacks.push(() => {
          setTimeout(() => {
            try {
              const x = onRejected(this.reason);
              this.resolvePromise(promise2, x, resolve, reject);
            } catch (error) {
              reject(error);
            }
          }, 0)
        })
      }
    }) 
    return promise2;   
  }

  // 处理Promise解析过程
  resolvePromise(promise2, x, resolve, reject) { 
    if (promise2 === x) {
      return reject(new TypeError('Chaining cycle detected for promise'));
    }

    // 防止多次调用
    let called = false;

    if (x !== null && (typeof x === 'object' || typeof x === 'function')) { 
      try { 
        const then = x.then;
        // 如果then是函数，认为x是promise
        if (typeof then === 'function') {
          // 执行x的then，传入resolvePromise和rejectPromise
          // 这里不能使用x.then, 因为会链式调用，导致then被多次调用
          then.call(x, (y) => { 
            if (called) return;
            called = true;
            this.resolvePromise(promise2, y, resolve, reject)
          }, (r) => { 
            if (called) return;
            called = true;
            reject(r)
          })
         }
      }
    }
  }

}
```

#### 6、数组排序 sort





