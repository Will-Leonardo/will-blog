---
title: 常见的手写功能
date: 2024-10-10
categories: 
 - 前端基础
---
<Boxx type='tip' />

参考： https://juejin.cn/post/7031322059414175774?utm_source=gold_browser_extension 


## 防抖
防抖好比法师发动技能，每次都要重新蓄力读条，进度条100%才会发出。

```js
function debounce(fn, delay) {
  let timer
  return function (...args) {
    if (timer) {
      clearTimeout(timer)
    }
    timer = setTimeout(() => {
      fn.apply(this, args)
    }, delay)
  }
}

// 测试
function scrolling() {
  console.log('is scrolling')
}
const debounceTask = debounce(scrolling, 1000)
window.addEventListener('scroll', debounceTask)
```

## 节流
节流好比fps射击游戏，你手速再快也会枪械射速的限制，单位时间内只会射出一颗子弹。

```js

function throttle(fn, delay) {
  let last = 0; // 上次触发的时间戳
  return (...args ) => {
    let now = Date.now()
    if(now - last > delay) {
      last = now
      fn.apply(this, args)
    }
  }
}

// 测试
function scrolling() {
  console.log('is scrolling')
}
const throttleTask = throttle(scrolling, 1000)
window.addEventListener('scroll', throttleTask)
```

## 深拷贝

深拷贝是指将原对象或数组的值复制到一个新的对象或数组中，并且新的对象或数组的属性或元素完全独立于原对象或数组，即它们不共享引用地址。因此，当我们修改其中一个对象或数组时，另一个对象或数组不会受到任何影响。

```js
// 不支持值为undefined、函数和循环引用的情况
const cloneObj = JSON.parse(JSON.stringify(obj))
```

递归实现
```js
const deepClone = (obj, cache = new WeakMap()) => {
  // 非引用类型 返回原值，注意 type null === 'object' 是js的历史缺陷
  if(obj === null || typeof obj !== 'object') return obj;
  if(obj instanceof Date) return new Date(obj)
  if(obj instanceof RegExp) return new RegExp(obj)

  // 如果出现循环引用，则返回缓存的对象，防止递归进入死循环
  if(cache.has(obj)) return cache.get(obj)

  let cloneObj = obj.constructor()
  cache.set(obj, cloneObj)

  for(let key in obj) {
    if(obj.hasOwnProperty(key)) {
      cloneObj[key] = deepClone(obj[key], cache)
    }
  }

  return cloneObj
}

const a = { name: 'will', score: { english: '150', math: '150' } }

const b = deepClone(a)

console.log(b)
```