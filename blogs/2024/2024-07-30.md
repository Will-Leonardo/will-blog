---
title: 新手前端工程师容易忽略的陷阱（持续更新）
date: 2024-07-30
categories: 
 - 总结记录
tags:
 - 踩坑指南
---

<Boxx type='tip' />

> **前言**：作为一名前端开发者，在日常开发中我们经常会遇到一些看似简单却容易被忽略的问题。这篇文章总结了一些新手前端工程师容易踩的坑，希望能帮助大家少走弯路。本文适合投喂给AICR进行AI代码评审，可以获得更多代码优化建议。

## 1、给 undefined 或 null 进行解构

解构赋值是ES6中非常实用的特性，但当我们尝试对`undefined`或`null`进行解构时，会遇到意想不到的错误：

```js

const getPerson = ()=>{}; // 函数没有返回值时，默认返回的是undefined
// 尝试解构undefined
const { name, age } = getPerson();
// Uncaught TypeError: Cannot destructure property 'name' of 'undefined' as it is undefined.

const article = api.getArticle(); // 假设这个函数返回null
// 尝试解构null
const { title, content } = article;
// Uncaught TypeError: Cannot destructure property 'title' of 'null' as it is null.
```

### 1.1 安全的解构方式

为了避免这类错误，我们可以使用默认值或条件判断：

```js
// 方法1：使用默认值
const { name, age } = someObj || {};

// 方法2：使用可选链操作符
const { title, content } = someObj?.data;

// 方法3：先进行判断
let userInfo = {};
if (response && response.data) {
  userInfo = response.data;
}
const { username, email } = userInfo;
```

### 1.2 解构并给默认值
```js
const { name = 'John Doe', age = 18 } = someObj || {};

// 先解构出来的变量可以作为后面解构出的变量的默认值
const { name = 'will', nickname = name } = someObj || {};
```

## 2、JSON.parse() 的常见陷阱

`JSON.parse()`通常用来将JSON字符串转换为JavaScript对象，也会用来做深拷贝，但解析前要确保你的数据是标准的JSON格式，否则会解析出错。

```js
JSON.parse(undefined) // Uncaught SyntaxError: "undefined" is not valid JSON
JSON.parse('') // Uncaught SyntaxError: Unexpected end of JSON input
JSON.parse('{name:"John"}') // Uncaught SyntaxError: Unexpected token n in JSON at position 1
```

### 2.1 JSON.parse() 的限制

- **循环引用**：如果对象中存在循环引用（即对象的某个属性指向了自身或其父对象），JSON.parse() 将会抛出一个错误。
- **函数和 undefined**：JSON.parse() 无法处理函数和 undefined 值。这些值在序列化过程中会被忽略。
- **日期对象**：日期对象在序列化后会被转换为字符串，反序列化后将不再是日期对象。
- **正则表达式**：正则表达式对象在序列化后会被转换为字符串，反序列化后将不再是正则表达式对象。
- **Symbol**：Symbol 类型的属性在序列化后会被忽略。
- **Map、Set 和 WeakMap、WeakSet**：这些数据结构在序列化后会被转换为普通对象，反序列化后将不再是原来的数据结构。
- **BigInt**：BigInt 类型的值在序列化后会被转换为字符串，反序列化后将不再是 BigInt 类型。
- **自定义对象**：如果对象中有自定义的方法或属性，这些方法或属性在序列化后会被丢失。
- **性能问题**：对于大型或复杂的对象，使用 JSON.parse() 进行深拷贝可能会导致性能问题。

### 2.2 安全的 JSON.parse 使用方式

```js
// 使用 try-catch 包裹 JSON.parse
function safeJSONParse(str, fallback = {}) {
  try {
    return JSON.parse(str);
  } catch (e) {
    console.error('JSON解析错误:', e);
    return fallback;
  }
}

// 使用
const data = safeJSONParse(localStorage.getItem('userSettings'), { theme: 'light' });
```

## 3、数组方法的返回值误区

容易混淆数组方法的返回值：

```js
// 修改原数组但不返回新数组的方法
const arr = [1, 2, 3];
const result1 = arr.push(4); // result1 = 4 (新长度)，而不是修改后的数组
const result2 = arr.splice(0, 1); // result2 = [1] (被删除的元素)，而不是修改后的数组

// 不修改原数组但返回新数组的方法
const arr2 = [1, 2, 3];
const mapped = arr2.map(x => x * 2); // mapped = [2, 4, 6]，arr2仍然是[1, 2, 3]
```

### 3.1 常见数组方法返回值速查表

| 方法 | 修改原数组 | 返回值 |
| --- | --- | --- |
| push() | ✅ | 新数组长度 |
| pop() | ✅ | 被删除的元素 |
| shift() | ✅ | 被删除的元素 |
| unshift() | ✅ | 新数组长度 |
| splice() | ✅ | 被删除元素的数组 |
| sort() | ✅ | 排序后的原数组 |
| reverse() | ✅ | 反转后的原数组 |
| map() | ❌ | 新数组 |
| filter() | ❌ | 新数组 |
| slice() | ❌ | 新数组 |
| concat() | ❌ | 新数组 |

## 4、事件监听器未移除导致的内存泄漏

在组件或页面中添加事件监听器后，如果在组件卸载或页面切换时没有正确移除，会导致内存泄漏(目前React 和 Vue 有实用的hooks函数，可挂载时使用addEventListener注册，卸载时自动removeEventListener)：

```js
// 错误示例
function setupEventListeners() {
  document.addEventListener('click', handleClick);
  window.addEventListener('resize', handleResize);
  // 组件卸载时没有移除监听器
}

// 正确示例
function setupEventListeners() {
  document.addEventListener('click', handleClick);
  window.addEventListener('resize', handleResize);
  
  // 返回清理函数
  return function cleanup() {
    document.removeEventListener('click', handleClick);
    window.removeEventListener('resize', handleResize);
  };
}

// 在React中
useEffect(() => {
  window.addEventListener('resize', handleResize);
  return () => {
    window.removeEventListener('resize', handleResize);
  };
}, []);
```

## 5、异步操作中的常见错误

### 5.1 忘记处理Promise的错误

```js
// 错误示例 - 未处理错误
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data));
  // 如果请求失败，错误会被吞掉

// 正确示例
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error('获取数据失败:', error));
```

### 5.2 async/await 中忘记 try/catch

```js
// 错误示例
async function fetchData() {
  const response = await fetch('https://api.example.com/data');
  const data = await response.json(); // 如果fetch失败，这里会抛出未捕获的错误
  return data;
}

// 正确示例
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`);
    }
    const data = await response.json();
    return data;
  } catch (error) {
    console.error('获取数据失败:', error);
    return null; // 或者其他错误处理逻辑
  }
}
```


## 6、flex-end导致overflow无法滚动

参考：[flex-end为什么overflow无法滚动及解决方法](https://www.zhangxinxu.com/wordpress/2021/12/flex-end-overflow/)

在 flex 布局中，如果整体列表项元素的对齐方式是 flex-end，则当里面的内容超过容器的时候，即使容器设置了 overflow:auto 也是无法有滚动效果的。

在 Web 网页中，滚动条出现是有方向性的要求的，由于全世界浏览文字，或者说阅读信息都是从上往下开始的，因此，滚动条的滚动也是从上往下。

所以滚动条在设计的时候，就约定了，只有容器下方（或右侧）内容有多余，才需要滚动，因为不可能说后续的阅读信息在阅读起点的上面，这不符合真实世界的阅读逻辑。

所以，这就导致，如果有内容是在上方或左侧超过容器的尺寸限制，滚动条是不会有任何变化的。

这样的现象其实大家应该都遇到过，那就是绝对定位隐藏只能设置一个大大的负值，但是不能设置一个大大的正值。
```css
.absolute-out {
  position: absolute;
  left: -999px; top: -999px;
}
```
但是如果是超出屏幕以外的正值，例如：
```css
.absolute-out {
  position: absolute;
  left: 150vw; top: 9999rem;
}
```
则就不行，因为此时页面会出现滚动条。







