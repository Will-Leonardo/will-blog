---
title: 吸顶和吸底布局
date: 2023-11-07
categories: 
 - Css
---
<Boxx type='tip' />

吸顶和吸底是很常见的一种布局。导航、索引等常常使用吸顶；合计、操作条常常使用吸底。

## position: sticky; 实现吸顶和吸底

几个要素要注意

- sticky元素的**父级或者祖先**元素不能有任何`overflow:visible`以外的`overflow`设置，否则没有粘滞效果
- 父级元素设置和粘性定位元素等高的固定的height高度值，或者高度计算值和粘性定位元素高度一样，也没有粘滞效果
- 同一个父容器中的sticky元素，如果定位值相等，则会重叠；如果属于不同父元素，且这些父元素正好紧密相连，则会鸠占鹊巢，挤开原来的元素，形成依次占位的效果
- 兼容性不乐观

```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    .wrap {
      min-height: 100vh;
    }
    .nav {
      background-color: skyblue;
      height: 100px;
      position: sticky;
      top: 0;
    }
    .content {
      background-color: palegreen;
      min-height: calc(100vh - 200px);
      height: 150vh;
    }
    .footer {
      height: 100px;
      background-color: gray;
      position: sticky;
      bottom: 0;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="nav">
      nav
    </div>
    <div class="content">
      content
    </div>
    <div class="footer">
      footer
    </div>
  </div>
</body>
</html>
```

不生效的时候可以重点排查下面三点：

1. 父级或祖先元素设置了不当的`overflow`
2. 父级元素是否和sticky元素等高
3. 是否未到临界值


## position: fixed; 固定定位

缺点： 不能随着滚动动态切换，

```css
.footer {
  position: fixed;
  left: 0;
  right: 0;
  bottom: 0;
  height: 200px;
}
```

## El-Affix 固钉组件

在`element` 中有固钉组件比`sticky`好使用一些; 

原理：监听滚动容器滚动事件，当滚动到设置的offset偏移量时，将需要固定的元素设置 `position: fixed`;

部分关键代码如下：

设置一个root父元素的作用是，给原来的元素留了一个影子站位，避免 固定定位的元素脱离了文档流，从而导致元素高度变小，导致布局错乱。

```js

<template>
  <div ref="root" :class="ns.b()" :style="rootStyle">
    <div :class="{ [ns.m('fixed')]: fixed }" :style="affixStyle">
      <slot />
    </div>
  </div>
</template>


// 更新状态，主要用于更新 fixed.value
const update = () => {
  if (!scrollContainer.value) return

  // instanceof是一个用于检查对象是否属于特定类型的运算符。它的语法是object instanceof constructor，
  // 其中object是要检查的对象，constructor是要检查的类型。
  scrollTop.value =
    scrollContainer.value instanceof Window
      ? document.documentElement.scrollTop
      : scrollContainer.value.scrollTop || 0

  // 吸顶
  if (props.position === 'top') {
    if (props.target) {
      const difference =
        targetRect.bottom.value - props.offset - rootHeight.value
      fixed.value = props.offset > rootTop.value && targetRect.bottom.value > 0
      transform.value = difference < 0 ? difference : 0
    } else {
      // 吸底
      // 当rootTop（距离顶部的距离）小于offset（设定的偏移距离）时固定
      fixed.value = props.offset > rootTop.value
    }
  } else if (props.target) {
    const difference =
      windowHeight.value -
      targetRect.top.value -
      props.offset -
      rootHeight.value
    fixed.value =
      windowHeight.value - props.offset < rootBottom.value &&
      windowHeight.value > targetRect.top.value
    transform.value = difference < 0 ? -difference : 0
  } else {
    fixed.value = windowHeight.value - props.offset < rootBottom.value
  }
}

const handleScroll = () => {
  updateRoot()
  emit('scroll', {
    scrollTop: scrollTop.value,
    fixed: fixed.value,
  })
}


useEventListener(scrollContainer, 'scroll', handleScroll)
```

## El-Affix 固钉组件改进

有些场景，我们希望 固定元素是在滚动容器中固定，不是相对视口；特别是在微前端中，这种场景比较多；例如顶部菜单是个子应用，内容区域又分了4个子应用，此时我们希望固定元素是在滚动容器中固定，不是相对视口；

部分修改代码如下：

我们需要得到滚动容器距离顶部的距离`containerTop.value` 然后将offset设置为 `${props.offset + containerTop.value}px`;

```js {5}
const affixStyle = computed<CSSProperties>(() => {
  if (!fixed.value) return {};
  let offset = '0px';
  if (props.noOverflowContainer) {
    offset = `${props.offset + containerTop.value}px`;
  } else {
    offset = `${props.offset}px`;
  }
  return {
    height: `${rootHeight.value}px`,
    width: `${props.noOverflowContainer ? scrollContainerWidth.value : rootWidth.value}px`,
    top: props.position === 'top' ? offset : '',
    bottom: props.position === 'bottom' ? offset : '',
    transform: transform.value ? `translateY(${transform.value}px)` : '',
    zIndex: props.zIndex,
  };
});
```
