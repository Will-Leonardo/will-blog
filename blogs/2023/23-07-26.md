---
title: useStorage源码阅读
date: 2023-07-26
categories: 
 - 日常笔记
---
<Boxx type='tip' />


## 1. ts 的函数多态

在TypeScript中，函数多态（Function Overloads）允许我们为同一个函数提供多个不同的类型签名。这样可以根据传入参数的类型来决定函数的行为。

要定义函数多态，可以使用函数重载（Function Overloads）的语法。下面是一个示例：

```ts
function processInput(input: string): string;
function processInput(input: number): number;
function processInput<T extends string | number>(input: T): T {
  if (typeof input === 'string') {
    return input.toUpperCase() as T;
  } else if (typeof input === 'number') {
    return input * 2 as T;
  }
}

const result1 = processInput("hello"); // result1的类型为string
const result2 = processInput(5); // result2的类型为number

```


## 2. ref 和 shallowRef

ref和shallowRef是Vue 3中的两个响应式函数。

- ref函数： 用于创建一个响应式的数据引用。它接收一个初始值作为参数，并返回一个包装了该值的响应式对象。当响应式对象的值发生变化时，相关的组件会自动重新渲染。

- shallowRef函数： 与ref函数类似，也用于创建一个响应式的数据引用。但是，与ref不同的是，shallowRef对于复杂对象只进行浅层响应式处理，即只有对象的第一层属性会被转换为响应式。这意味着当复杂对象的属性值发生变化时，相关的组件不会自动重新渲染。

总结来说，ref用于创建普通的响应式数据引用，而shallowRef用于创建浅层响应式数据引用。


## 3. 自定义类型

```ts
/**
 * A ref that allow to set null or undefined
 */
export type RemovableRef<T> = Omit<Ref<T>, 'value'> & {
  get value(): T
  set value(value: T | null | undefined)
}
```

先使用了 `Omit` 工具类型创建了一个 将 `Ref<T>`中去掉 `value` 的类型，再使用 `&`交叉 一个 `value`可为
`null`、`undefined` 的类型， 这样就创建了一个 可以为 `null` or `undefined` 的 `ref`

```ts
export type AnyFn = (...args: any[]) => any
```

## 4. == null 和 === null

如果我们想要检查一个值是否为`null`或`undefined`，使用`== null`可以更加简洁和方便，因为它会同时检查这两种情况。而如果我们只想检查一个值是否严格等于`null`，则可以使用`=== null`


