---
title: 前端路由篇
date: 2023-06-01
categories: 
 - 日常笔记
---
<Boxx type='tip' />

## 什么是前端路由？

前端路由是指在单页应用（SPA）中，通过JavaScript实现的一种<B>页面跳转</B>方式。它可以在**不刷新整个页面**的情况下，改变URL并更新页面内容，从而提升用户体验。前端路由通常使用浏览器的**History API或Hash（#）**来实现。其中，**History API可以通过pushState和replaceState方法来改变URL**，而**Hash则是通过window.location.hash属性来实现**。在使用前端路由时，需要注意页面的SEO问题，以及浏览器的兼容性。

## hash模式

:strawberry: 前置知识：

1. URL是由很多部分组成，包括协议、域名、路径、query、hash等, 

首页：yourdomain.xxx.com/index.html/#/
商城：yourdomain.xxx.com/index.html/#/shop
购物车：yourdomain.xxx.com/index.html/#/shopping-cart
我的：yourdomain.xxx.com/index.html/#/mine

#号后面的，就是一个URL中关于hash的组成部分，可以看到，不同路由对应的hash是不一样的，但是它们都是在访问同一个静态资源index.html

```js {7,8}
<script>
  class VueRouter {
    constructor(routes  = []){
      this.routes = routes;
      this.curentHash = ''; // 当前路由hash
      this.refresh = this.refresh.bind(this);
      window.addEventListener('load', this.refresh, false);
      window.addEventListener('hashchange', this.refresh, false);
    }

    getUrlHash(url){
      return url.indexOf('#') >= 0 ? url.slice(url.indexOf('#')+1) : '/'
    }
    refresh(event){
      this.curentHash =this.getUrlHash(window.location.hash);
      this.mathComponent();
    }
    mathComponent() {
      let curRoute = this.routes.find(route=> route.path === this.curentHash);
      if(!curRoute){
        curRoute === this.routes.find(route => route.path === '#/')
      }
      const { component } = curRoute;
      document.querySelector('#content').innerHTML = component;
    }
  }

  const route = new VueRouter([
    {
      path: '/',
      name: 'home',
      component: `<div>首页内容<div>`
    },
    {
      path: '/shop',
      name: 'shop',
      component: `<div>商城内容<div>`
    },
    {
      path: '/shopping-cart',
      name: 'shopping-cart',
      component: `<div>商城内容<div>`
    },
    {
      path: '/mine',
      name: 'mine',
      component: `<div>我的内容<div>`
    }
  ])
</script>
```

## History模式

:strawberry: 前置知识

history全局对象

- window.history.go 可以跳转到浏览器会话历史中的指定的某一个记录页
- window.history.forward 指向浏览器会话历史中的下一页，跟浏览器的前进按钮相同
- window.history.back 返回浏览器会话历史中的上一页，跟浏览器的回退按钮功能相同
- window.history.pushState 可以将给定的数据压入到浏览器会话历史栈中
- window.history.replaceState 将当前的会话页面的url替换成指定的数据

而history路由的实现，主要就是依靠于**pushState与replaceState**实现的，这里我们先总结下它们的一些特点

都会改变当前页面显示的url，但都不会刷新页面
pushState是压入浏览器的会话历史栈中，会使得history.length加1，而replaceState是替换当前的这条会话历史，因此不会增加history.length

```js
class VueRouter {
  constructor(options) {
    this.routes = options.routes;
    this.mode = options.mode || 'hash';
    this.history = [];
    this.current = null;
    this.init();
  }

  init() {
    if (this.mode === 'hash') {
      window.addEventListener('hashchange', this.hashChange.bind(this));
      this.hashChange();
    } else {
      window.addEventListener('popstate', this.popstateChange.bind(this));
      this.popstateChange();
    }
  }

  hashChange() {
    const hash = window.location.hash.slice(1);
    this.history.push(hash);
    this.current = hash;
    this.render();
  }

  popstateChange() {
    const path = window.location.pathname;
    this.history.push(path);
    this.current = path;
    this.render();
  }

  render() {
    const route = this.routes.find(route => route.path === this.current);
    if (route) {
      document.querySelector('#app').innerHTML = route.component;
    }
  }
}

```

**重要：**

hash模式是不需要后端服务配合的。但是history模式下，如果你再跳转路由后再次刷新会得到404的错误，这个错误说白了就是浏览器会把整个地址当成一个可访问的静态资源路径进行访问，然后服务端并没有这个文件～看下面例子更好理解

```js
http://192.168.30.161:5500/ === http://192.168.30.161:5500/index.html // 默认访问路径下的index.html文件，没毛病
http://192.168.30.161:5500/home === http://192.168.30.161:5500/index.html // 仍然访问路径下的index.html文件，没毛病
...
http://192.168.30.161:5500/mine === http://192.168.30.161:5500/index.html // 所有的路由都是访问路径下的index.html，没毛病

```

```js
http://192.168.30.161:5500/mine === http://192.168.30.161:5500/mine/index.html文件，出问题了，服务器上并没有这个资源，404😭

```

所以一般情况下，我们都需要配置下nginx，告诉服务器，当我们访问的路径资源不存在的时候，默认指向静态资源index.html

```js
location / {
  try_files $uri $uri/ /index.html;
}
```

参考文章

- [面试官为啥总是喜欢问前端路由实现方式？](https://juejin.cn/post/7127143415879303204#heading-2)